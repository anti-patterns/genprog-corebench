WARNING: the argument --multi-file is deprecated. This is not fatal, as GenProg can handle certain deprecated options as of the March 2012 refactor.
However, you may want to consult the GenProg documentation to avoid using 
deprecated options in the future, and verify that your config is doing what you
think it is doing.WARNING: the argument --suffix-extension is deprecated. This is not fatal, as GenProg can handle certain deprecated options as of the March 2012 refactor.
However, you may want to consult the GenProg documentation to avoid using 
deprecated options in the future, and verify that your config is doing what you
think it is doing.WARNING: the argument --mutp is deprecated. This is not fatal, as GenProg can handle certain deprecated options as of the March 2012 refactor.
However, you may want to consult the GenProg documentation to avoid using 
deprecated options in the future, and verify that your config is doing what you
think it is doing.--allow-coverage-fail true
--anti-append-returngoto false
--anti-delete-cfgblock false
--anti-delete-empty false
--anti-delete-exit false
--anti-delete-setbeforeif false
--anti-delete-setinsideloop false
--appp 0.33333
--asm-code-only false
--best-edit-rule "1 * fault_loc_weight ; 1 * max_test_fail_prob ; -1 * num_tests"
--best-test-rule "1 * test_fail_prob ; 1 * test_fail_count ; -1 * test_pass_count"
--compiler "gcc"
--compiler-command "perl compile.pl __EXE_NAME__ > /dev/null"
--compiler-opts ""
--continue false
--coverage-info ""
--coverage-per-test false
--crossover "subset"
--crossp 0.5
--delp 0.33333
--describe-machine true
--diversity-selection 0
--edit-script false
--elf-risc false
--exclude-edits ""
--exp-diff false
--fault-file ""
--fault-path "coverage.path.neg"
--fault-scheme "path"
--fitness-in-parallel 2
--fix-file ""
--fix-oracle ""
--fix-path "coverage.path.pos"
--fix-scheme "default"
--flatten-path ""
--format "txt"
--gen-per-exchange 1
--generations 10
--gui false
--hostname "127.0.0.1"
--ignore-dead-code true
--ignore-equiv-appends true
--ignore-standard-headers true
--ignore-string-equiv-fixes true
--ignore-untyped-returns false
--incoming-pop ""
--keep-source false
--label-repair true
--max-evals 0
--minimization false
--mt-cov false
--multiopt-minimize false
--multiopt-no-inf false
--neg-tests 1
--neg-weight 1
--negative-test-weight 2
--neutral-walk-max-size 0
--neutral-walk-weight ""
--nht-id "global"
--nht-port 51000
--nht-server ""
--no-delete false
--no-rep-cache true
--no-test-cache true
--num-comps 2
--num-objectives 2
--oracle-genome ""
--popsize 40
--port 60000
--pos-tests 2
--pos-weight 0.1
--prefix "preprocessed"
--preprocessor ""
--print-incremental-evals false
--print-source-name false
--program "bugged-program.txt"
--promut 1
--quiet false
--regen-paths false
--rep "cilpatch"
--rep-cache "default.cache"
--repp 0
--samp-strat "variant"
--sample 1
--sample-runs 100
--sanity "no"
--search "ww"
--seed 0
--semantic-check "scope"
--single-fitness false
--skip-failed-sanity-tests true
--skip-tests ""
--split-search 0
--sport 65000
--subatom-constp 0.5
--subatom-mutp 0
--super-mutant false
--super-mutant-size 50
--swap-bug false
--swapp 0.33333
--template-cache ""
--templates ""
--test-command "timeout -k 75s 75s __TEST_SCRIPT__ __TEST_NAME__"
--test-script "./test.sh"
--tournament-size 2
--tweet false
--uniq false
--valgrind false
--variants-exchanged 50
uname -a: Linux genprog-shinhwei2 3.19.0-43-generic #49~14.04.1-Ubuntu SMP Thu Dec 31 15:44:49 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
date: Mon Feb  1 13:58:13 SGT 2016
id: uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),27(sudo)
cat: /etc/redhat-release: No such file or directory
cat /etc/redhat-release: End_of_file
grep 'model name' /proc/cpuinfo: model name	: Intel(R) Xeon(R) CPU E5-2660 v3 @ 2.60GHz
grep 'MemTotal' /proc/meminfo: MemTotal:       65861644 kB
grep 'SwapTotal' /proc/meminfo: SwapTotal:      67006460 kB
cilRep: preprocessing IO function signatures: /tmp/tmp3114b8.c /tmp/tmpc42fd7.c
cilRep: done preprocessing IO function signatures
cilrep: from_source: pre: stmt_count = 1
cilRep: src/dfa.c: parsing
cilRep: src/dfa.c: parsed (0.329799 MB)
cilRep: computing liveness
Bug: BF(Liveness): stmtStartData is not initialized for -1: __Cont: 
#line 809 "dfa.c"
wc = wc1;
#line 809
c = c1;
Liveness failed on function:
 static token parse_bracket_exp(void) 
{ int invert ;
  int c ;
  int c1 ;
  int c2 ;
  charclass ccl ;
  int colon_warning_state ;
  wint_t wc ;
  wint_t wc1 ;
  wint_t wc2 ;
  struct mb_char_classes *work_mbc ;
  int chars_al ;
  int range_sts_al ;
  int range_ends_al ;
  int ch_classes_al ;
  int equivs_al ;
  int coll_elems_al ;
  size_t new_nalloc ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  wchar_t _wc ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  wchar_t _wc___0 ;
  size_t tmp___9 ;
  char const   *tmp___10 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___11 ;
  char str[128] ;
  char *tmp___12 ;
  char *tmp___13 ;
  wchar_t _wc___1 ;
  size_t tmp___14 ;
  char const   *tmp___15 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___16 ;
  size_t len ;
  char *tmp___17 ;
  char *tmp___18 ;
  wchar_t _wc___2 ;
  size_t tmp___19 ;
  char const   *tmp___20 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___21 ;
  size_t tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  wchar_t _wc___3 ;
  size_t tmp___25 ;
  char const   *tmp___26 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___27 ;
  char const   *class ;
  char const   *tmp___42 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___51 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  struct dfa_ctype  const  *pred ;
  struct dfa_ctype  const  *tmp___57 ;
  char *tmp___58 ;
  wctype_t wt ;
  wctype_t tmp___59 ;
  void *tmp___60 ;
  void *tmp___61 ;
  void *tmp___62 ;
  size_t new_nalloc___0 ;
  void *tmp___63 ;
  int tmp___64 ;
  size_t tmp___65 ;
  int tmp___66 ;
  char *elem ;
  void *tmp___67 ;
  void *tmp___68 ;
  void *tmp___69 ;
  void *tmp___70 ;
  void *tmp___71 ;
  void *tmp___72 ;
  size_t new_nalloc___1 ;
  void *tmp___73 ;
  int tmp___74 ;
  void *tmp___75 ;
  void *tmp___76 ;
  void *tmp___77 ;
  size_t new_nalloc___2 ;
  void *tmp___78 ;
  int tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  wchar_t _wc___4 ;
  size_t tmp___82 ;
  char const   *tmp___83 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___84 ;
  size_t tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;
  wchar_t _wc___5 ;
  size_t tmp___88 ;
  char const   *tmp___89 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___90 ;
  char *tmp___91 ;
  char *tmp___92 ;
  wchar_t _wc___6 ;
  size_t tmp___93 ;
  char const   *tmp___94 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  wchar_t _wc___7 ;
  size_t tmp___98 ;
  char const   *tmp___99 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  wchar_t _wc___8 ;
  size_t tmp___103 ;
  char const   *tmp___104 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___105 ;
  void *tmp___106 ;
  void *tmp___107 ;
  void *tmp___108 ;
  void *tmp___109 ;
  void *tmp___110 ;
  void *tmp___111 ;
  size_t new_nalloc___3 ;
  void *tmp___112 ;
  size_t new_nalloc___4 ;
  void *tmp___113 ;
  wint_t tmp___114 ;
  int tmp___115 ;
  wint_t tmp___116 ;
  int __res ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___118 ;
  __int32_t const   **tmp___119 ;
  int __res___0 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___121 ;
  __int32_t const   **tmp___122 ;
  regex_t re ;
  char pattern[6] ;
  char subject[2] ;
  unsigned short const   **tmp___123 ;
  int tmp___124 ;
  size_t tmp___125 ;
  char *tmp___126 ;
  char *tmp___127 ;
  wchar_t _wc___9 ;
  size_t tmp___128 ;
  char const   *tmp___129 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___130 ;
  int tmp___131 ;
  size_t new_nalloc___5 ;
  void *tmp___132 ;
  int tmp___133 ;
  _Bool tmp___134 ;
  int tmp___135 ;
  size_t new_nalloc___6 ;
  void *tmp___136 ;
  int tmp___137 ;
  _Bool tmp___138 ;
  size_t tmp___139 ;
  char *tmp___140 ;
  int tmp___142 ;
  int tmp___143 ;
  size_t tmp___144 ;
  size_t tmp___145 ;
  int tmp___146 ;

  {
   1482: /* CIL Label */ 
#line 778
  chars_al = 1;
   1483: /* CIL Label */ 
#line 779
  range_ends_al = 0;
   1484: /* CIL Label */ 
#line 779
  range_sts_al = range_ends_al;
   1485: /* CIL Label */ 
#line 780
  coll_elems_al = 0;
   1486: /* CIL Label */ 
#line 780
  equivs_al = coll_elems_al;
   1487: /* CIL Label */ 
#line 780
  ch_classes_al = equivs_al;
   1488: /* CIL Label */ 
#line 781
  tmp___1 = __ctype_get_mb_cur_max();
   1489: /* CIL Label */ 
#line 781
  if (tmp___1 > 1UL) {
#line 783
    while (1) {
#line 783
      if (dfa->mbcsets_alloc <= dfa->nmbcsets + 1) {
#line 783
        new_nalloc = (unsigned long )((dfa->nmbcsets + 1) + ! dfa->mbcsets);
#line 783
        tmp = x2nrealloc((void *)dfa->mbcsets, & new_nalloc,
                         sizeof(struct mb_char_classes ));
#line 783
        dfa->mbcsets = (struct mb_char_classes *)tmp;
#line 783
        dfa->mbcsets_alloc = (int )new_nalloc;
      } else {

      }
#line 783
      break;
    }
#line 791
    tmp___0 = dfa->nmbcsets;
#line 791
    (dfa->nmbcsets) ++;
#line 791
    work_mbc = dfa->mbcsets + tmp___0;
#line 792
    memset((void *)work_mbc, 0, sizeof(*work_mbc));
  } else {
#line 795
    work_mbc = (struct mb_char_classes *)((void *)0);
  }
   1490: /* CIL Label */ 
#line 798
  memset((void *)(ccl), 0, sizeof(ccl));
   1491: /* CIL Label */ 
#line 799
  while (1) {
#line 799
    if (! lexleft) {
#line 799
      tmp___3 = dcgettext((char const   *)((void *)0), "unbalanced [", 5);
#line 799
      if ((unsigned long )tmp___3 != (unsigned long )((char *)0)) {
#line 799
        tmp___2 = dcgettext((char const   *)((void *)0), "unbalanced [", 5);
#line 799
        dfaerror((char const   *)tmp___2);
      } else {
#line 799
        lasttok = (enum __anonenum_token_32 )-1;
#line 799
        return (lasttok);
      }
    } else {
#line 799
      tmp___4 = mbrtowc((wchar_t */* __restrict  */)(& _wc),
                        (char const   */* __restrict  */)lexptr,
                        (unsigned long )lexleft,
                        (mbstate_t */* __restrict  */)(& mbs));
#line 799
      cur_mb_len = (int )tmp___4;
#line 799
      if (cur_mb_len <= 0) {
#line 799
        cur_mb_len = 1;
#line 799
        lexleft --;
#line 799
        tmp___5 = lexptr;
#line 799
        lexptr ++;
#line 799
        c = (int )((unsigned char )*tmp___5);
#line 799
        wc = (unsigned int )c;
      } else {
#line 799
        lexptr += cur_mb_len;
#line 799
        lexleft -= cur_mb_len;
#line 799
        wc = (unsigned int )_wc;
#line 799
        tmp___6 = wctob(wc);
#line 799
        c = (int )tmp___6;
      }
    }
#line 799
    break;
  }
   1492: /* CIL Label */ 
#line 800
  if (c == 94) {
#line 802
    while (1) {
#line 802
      if (! lexleft) {
#line 802
        tmp___8 = dcgettext((char const   *)((void *)0), "unbalanced [", 5);
#line 802
        if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
#line 802
          tmp___7 = dcgettext((char const   *)((void *)0), "unbalanced [", 5);
#line 802
          dfaerror((char const   *)tmp___7);
        } else {
#line 802
          lasttok = (enum __anonenum_token_32 )-1;
#line 802
          return (lasttok);
        }
      } else {
#line 802
        tmp___9 = mbrtowc((wchar_t */* __restrict  */)(& _wc___0),
                          (char const   */* __restrict  */)lexptr,
                          (unsigned long )lexleft,
                          (mbstate_t */* __restrict  */)(& mbs));
#line 802
        cur_mb_len = (int )tmp___9;
#line 802
        if (cur_mb_len <= 0) {
#line 802
          cur_mb_len = 1;
#line 802
          lexleft --;
#line 802
          tmp___10 = lexptr;
#line 802
          lexptr ++;
#line 802
          c = (int )((unsigned char )*tmp___10);
#line 802
          wc = (unsigned int )c;
        } else {
#line 802
          lexptr += cur_mb_len;
#line 802
          lexleft -= cur_mb_len;
#line 802
          wc = (unsigned int )_wc___0;
#line 802
          tmp___11 = wctob(wc);
#line 802
          c = (int )tmp___11;
        }
      }
#line 802
      break;
    }
#line 803
    invert = 1;
  } else {
#line 806
    invert = 0;
  }
   1493: /* CIL Label */ 
#line 808
  colon_warning_state = c == 58;
   1494: /* CIL Label */ 
#line 809
  while (1) {
#line 811
    c1 = -1;
#line 812
    colon_warning_state &= -3;
#line 818
    if (c == 91) {
#line 818
      if (syntax_bits & ((1UL << 1) << 1)) {
#line 822
        while (1) {
#line 822
          if (! lexleft) {
#line 822
            tmp___13 = dcgettext((char const   *)((void *)0), "unbalanced [", 5);
#line 822
            if ((unsigned long )tmp___13 != (unsigned long )((char *)0)) {
#line 822
              tmp___12 = dcgettext((char const   *)((void *)0), "unbalanced [",
                                   5);
#line 822
              dfaerror((char const   *)tmp___12);
            } else {
#line 822
              lasttok = (enum __anonenum_token_32 )-1;
#line 822
              return (lasttok);
            }
          } else {
#line 822
            tmp___14 = mbrtowc((wchar_t */* __restrict  */)(& _wc___1),
                               (char const   */* __restrict  */)lexptr,
                               (unsigned long )lexleft,
                               (mbstate_t */* __restrict  */)(& mbs));
#line 822
            cur_mb_len = (int )tmp___14;
#line 822
            if (cur_mb_len <= 0) {
#line 822
              cur_mb_len = 1;
#line 822
              lexleft --;
#line 822
              tmp___15 = lexptr;
#line 822
              lexptr ++;
#line 822
              c1 = (int )((unsigned char )*tmp___15);
#line 822
              wc1 = (unsigned int )c1;
            } else {
#line 822
              lexptr += cur_mb_len;
#line 822
              lexleft -= cur_mb_len;
#line 822
              wc1 = (unsigned int )_wc___1;
#line 822
              tmp___16 = wctob(wc1);
#line 822
              c1 = (int )tmp___16;
            }
          }
#line 822
          break;
        }
#line 825
        if (c1 == 58) {
          goto _L___10;
        } else {
#line 825
          tmp___85 = __ctype_get_mb_cur_max();
#line 825
          if (tmp___85 > 1UL) {
#line 825
            if (c1 == 46) {
              goto _L___10;
            } else {
#line 825
              if (c1 == 61) {
                _L___10: 
#line 832
                len = 0UL;
#line 833
                while (1) {
#line 835
                  while (1) {
#line 835
                    if (! lexleft) {
#line 835
                      tmp___18 = dcgettext((char const   *)((void *)0),
                                           "unbalanced [", 5);
#line 835
                      if ((unsigned long )tmp___18 != (unsigned long )((char *)0)) {
#line 835
                        tmp___17 = dcgettext((char const   *)((void *)0),
                                             "unbalanced [", 5);
#line 835
                        dfaerror((char const   *)tmp___17);
                      } else {
#line 835
                        lasttok = (enum __anonenum_token_32 )-1;
#line 835
                        return (lasttok);
                      }
                    } else {
#line 835
                      tmp___19 = mbrtowc((wchar_t */* __restrict  */)(& _wc___2),
                                         (char const   */* __restrict  */)lexptr,
                                         (unsigned long )lexleft,
                                         (mbstate_t */* __restrict  */)(& mbs));
#line 835
                      cur_mb_len = (int )tmp___19;
#line 835
                      if (cur_mb_len <= 0) {
#line 835
                        cur_mb_len = 1;
#line 835
                        lexleft --;
#line 835
                        tmp___20 = lexptr;
#line 835
                        lexptr ++;
#line 835
                        c = (int )((unsigned char )*tmp___20);
#line 835
                        wc = (unsigned int )c;
                      } else {
#line 835
                        lexptr += cur_mb_len;
#line 835
                        lexleft -= cur_mb_len;
#line 835
                        wc = (unsigned int )_wc___2;
#line 835
                        tmp___21 = wctob(wc);
#line 835
                        c = (int )tmp___21;
                      }
                    }
#line 835
                    break;
                  }
#line 836
                  if (c == c1) {
#line 836
                    if ((int const   )*lexptr == 93) {
#line 837
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: 
#line 836
                    if (lexleft == 0) {
#line 837
                      break;
                    } else {

                    }
                  }
#line 838
                  if (len < 128UL) {
#line 839
                    tmp___22 = len;
#line 839
                    len ++;
#line 839
                    str[tmp___22] = (char )c;
                  } else {
#line 842
                    str[0] = (char )'\000';
                  }
                }
#line 844
                str[len] = (char )'\000';
#line 847
                while (1) {
#line 847
                  if (! lexleft) {
#line 847
                    tmp___24 = dcgettext((char const   *)((void *)0),
                                         "unbalanced [", 5);
#line 847
                    if ((unsigned long )tmp___24 != (unsigned long )((char *)0)) {
#line 847
                      tmp___23 = dcgettext((char const   *)((void *)0),
                                           "unbalanced [", 5);
#line 847
                      dfaerror((char const   *)tmp___23);
                    } else {
#line 847
                      lasttok = (enum __anonenum_token_32 )-1;
#line 847
                      return (lasttok);
                    }
                  } else {
#line 847
                    tmp___25 = mbrtowc((wchar_t */* __restrict  */)(& _wc___3),
                                       (char const   */* __restrict  */)lexptr,
                                       (unsigned long )lexleft,
                                       (mbstate_t */* __restrict  */)(& mbs));
#line 847
                    cur_mb_len = (int )tmp___25;
#line 847
                    if (cur_mb_len <= 0) {
#line 847
                      cur_mb_len = 1;
#line 847
                      lexleft --;
#line 847
                      tmp___26 = lexptr;
#line 847
                      lexptr ++;
#line 847
                      c = (int )((unsigned char )*tmp___26);
#line 847
                      wc = (unsigned int )c;
                    } else {
#line 847
                      lexptr += cur_mb_len;
#line 847
                      lexleft -= cur_mb_len;
#line 847
                      wc = (unsigned int )_wc___3;
#line 847
                      tmp___27 = wctob(wc);
#line 847
                      c = (int )tmp___27;
                    }
                  }
#line 847
                  break;
                }
#line 848
                if (c1 == 58) {
#line 853
                  if (case_fold) {
#line 852
                    if (0) {
#line 852
                      __s1_len___1 = __builtin_strlen((char const   *)(str));
#line 852
                      __s2_len___1 = __builtin_strlen("upper");
#line 852
                      if (! ((unsigned long )((void const   *)(str + 1)) - (unsigned long )((void const   *)(str)) == 1UL)) {
                        goto _L___5;
                      } else {
#line 852
                        if (__s1_len___1 >= 4UL) {
                          _L___5: 
#line 852
                          if (! ((unsigned long )((void const   *)("upper" + 1)) - (unsigned long )((void const   *)"upper") == 1UL)) {
#line 852
                            tmp___49 = 1;
                          } else {
#line 852
                            if (__s2_len___1 >= 4UL) {
#line 852
                              tmp___49 = 1;
                            } else {
#line 852
                              tmp___49 = 0;
                            }
                          }
                        } else {
#line 852
                          tmp___49 = 0;
                        }
                      }
#line 852
                      if (tmp___49) {
#line 852
                        tmp___44 = __builtin_strcmp((char const   *)(str),
                                                    "upper");
#line 852
                        tmp___48 = tmp___44;
                      } else {
#line 852
                        tmp___47 = __builtin_strcmp((char const   *)(str),
                                                    "upper");
#line 852
                        tmp___48 = tmp___47;
                      }
                    } else {
#line 852
                      tmp___47 = __builtin_strcmp((char const   *)(str), "upper");
#line 852
                      tmp___48 = tmp___47;
                    }
#line 853
                    if (tmp___48 == 0) {
#line 853
                      tmp___42 = "alpha";
                    } else {
#line 853
                      if (0) {
#line 853
                        __s1_len___2 = __builtin_strlen((char const   *)(str));
#line 853
                        __s2_len___2 = __builtin_strlen("lower");
#line 853
                        if (! ((unsigned long )((void const   *)(str + 1)) - (unsigned long )((void const   *)(str)) == 1UL)) {
                          goto _L___7;
                        } else {
#line 853
                          if (__s1_len___2 >= 4UL) {
                            _L___7: 
#line 853
                            if (! ((unsigned long )((void const   *)("lower" + 1)) - (unsigned long )((void const   *)"lower") == 1UL)) {
#line 853
                              tmp___56 = 1;
                            } else {
#line 853
                              if (__s2_len___2 >= 4UL) {
#line 853
                                tmp___56 = 1;
                              } else {
#line 853
                                tmp___56 = 0;
                              }
                            }
                          } else {
#line 853
                            tmp___56 = 0;
                          }
                        }
#line 853
                        if (tmp___56) {
#line 853
                          tmp___51 = __builtin_strcmp((char const   *)(str),
                                                      "lower");
#line 853
                          tmp___55 = tmp___51;
                        } else {
#line 853
                          tmp___54 = __builtin_strcmp((char const   *)(str),
                                                      "lower");
#line 853
                          tmp___55 = tmp___54;
                        }
                      } else {
#line 853
                        tmp___54 = __builtin_strcmp((char const   *)(str),
                                                    "lower");
#line 853
                        tmp___55 = tmp___54;
                      }
#line 853
                      if (tmp___55 == 0) {
#line 853
                        tmp___42 = "alpha";
                      } else {
#line 853
                        tmp___42 = (char const   *)(str);
                      }
                    }
                  } else {
#line 853
                    tmp___42 = (char const   *)(str);
                  }
#line 853
                  class = tmp___42;
#line 856
                  tmp___57 = find_pred(class);
#line 856
                  pred = tmp___57;
#line 857
                  if (! pred) {
#line 858
                    tmp___58 = dcgettext((char const   *)((void *)0),
                                         "invalid character class", 5);
#line 858
                    dfaerror((char const   *)tmp___58);
                  } else {

                  }
#line 861
                  tmp___65 = __ctype_get_mb_cur_max();
#line 861
                  if (tmp___65 > 1UL) {
#line 861
                    if (! pred->single_byte_only) {
#line 864
                      tmp___59 = wctype(class);
#line 864
                      wt = tmp___59;
#line 866
                      if (ch_classes_al == 0) {
#line 867
                        if (sizeof(wctype_t ) == 1UL) {
#line 867
                          ch_classes_al ++;
#line 867
                          tmp___60 = xmalloc((unsigned long )ch_classes_al);
#line 867
                          tmp___62 = tmp___60;
                        } else {
#line 867
                          ch_classes_al ++;
#line 867
                          tmp___61 = xnmalloc((unsigned long )ch_classes_al,
                                              sizeof(wctype_t ));
#line 867
                          tmp___62 = tmp___61;
                        }
#line 867
                        work_mbc->ch_classes = (wctype_t *)tmp___62;
                      } else {

                      }
#line 868
                      while (1) {
#line 868
                        if (ch_classes_al <= work_mbc->nch_classes + 1) {
#line 868
                          new_nalloc___0 = (unsigned long )((work_mbc->nch_classes + 1) + ! work_mbc->ch_classes);
#line 868
                          tmp___63 = x2nrealloc((void *)work_mbc->ch_classes,
                                                & new_nalloc___0,
                                                sizeof(wctype_t ));
#line 868
                          work_mbc->ch_classes = (wctype_t *)tmp___63;
#line 868
                          ch_classes_al = (int )new_nalloc___0;
                        } else {

                        }
#line 868
                        break;
                      }
#line 871
                      tmp___64 = work_mbc->nch_classes;
#line 871
                      (work_mbc->nch_classes) ++;
#line 871
                      *(work_mbc->ch_classes + tmp___64) = wt;
                    } else {

                    }
                  } else {

                  }
#line 875
                  c2 = 0;
#line 875
                  while (c2 < 1 << 8) {
#line 876
                    tmp___66 = (*(pred->func))(c2);
#line 876
                    if (tmp___66) {
#line 877
                      setbit_case_fold_c(c2, ccl);
                    } else {

                    }
#line 875
                    c2 ++;
                  }
                } else {
#line 881
                  if (c1 == 61) {
                    goto _L___8;
                  } else {
#line 881
                    if (c1 == 46) {
                      _L___8: 
#line 884
                      if (sizeof(char ) == 1UL) {
#line 884
                        tmp___67 = xmalloc(len + 1UL);
#line 884
                        tmp___69 = tmp___67;
                      } else {
#line 884
                        tmp___68 = xnmalloc(len + 1UL, sizeof(char ));
#line 884
                        tmp___69 = tmp___68;
                      }
#line 884
                      elem = (char *)tmp___69;
#line 885
                      strncpy((char */* __restrict  */)elem,
                              (char const   */* __restrict  */)(str), len + 1UL);
#line 887
                      if (c1 == 61) {
#line 890
                        if (equivs_al == 0) {
#line 891
                          if (sizeof(char *) == 1UL) {
#line 891
                            equivs_al ++;
#line 891
                            tmp___70 = xmalloc((unsigned long )equivs_al);
#line 891
                            tmp___72 = tmp___70;
                          } else {
#line 891
                            equivs_al ++;
#line 891
                            tmp___71 = xnmalloc((unsigned long )equivs_al,
                                                sizeof(char *));
#line 891
                            tmp___72 = tmp___71;
                          }
#line 891
                          work_mbc->equivs = (char **)tmp___72;
                        } else {

                        }
#line 892
                        while (1) {
#line 892
                          if (equivs_al <= work_mbc->nequivs + 1) {
#line 892
                            new_nalloc___1 = (unsigned long )((work_mbc->nequivs + 1) + ! work_mbc->equivs);
#line 892
                            tmp___73 = x2nrealloc((void *)work_mbc->equivs,
                                                  & new_nalloc___1,
                                                  sizeof(char *));
#line 892
                            work_mbc->equivs = (char **)tmp___73;
#line 892
                            equivs_al = (int )new_nalloc___1;
                          } else {

                          }
#line 892
                          break;
                        }
#line 895
                        tmp___74 = work_mbc->nequivs;
#line 895
                        (work_mbc->nequivs) ++;
#line 895
                        *(work_mbc->equivs + tmp___74) = elem;
                      } else {

                      }
#line 898
                      if (c1 == 46) {
#line 901
                        if (coll_elems_al == 0) {
#line 902
                          if (sizeof(char *) == 1UL) {
#line 902
                            coll_elems_al ++;
#line 902
                            tmp___75 = xmalloc((unsigned long )coll_elems_al);
#line 902
                            tmp___77 = tmp___75;
                          } else {
#line 902
                            coll_elems_al ++;
#line 902
                            tmp___76 = xnmalloc((unsigned long )coll_elems_al,
                                                sizeof(char *));
#line 902
                            tmp___77 = tmp___76;
                          }
#line 902
                          work_mbc->coll_elems = (char **)tmp___77;
                        } else {

                        }
#line 903
                        while (1) {
#line 903
                          if (coll_elems_al <= work_mbc->ncoll_elems + 1) {
#line 903
                            new_nalloc___2 = (unsigned long )((work_mbc->ncoll_elems + 1) + ! work_mbc->coll_elems);
#line 903
                            tmp___78 = x2nrealloc((void *)work_mbc->coll_elems,
                                                  & new_nalloc___2,
                                                  sizeof(char *));
#line 903
                            work_mbc->coll_elems = (char **)tmp___78;
#line 903
                            coll_elems_al = (int )new_nalloc___2;
                          } else {

                          }
#line 903
                          break;
                        }
#line 906
                        tmp___79 = work_mbc->ncoll_elems;
#line 906
                        (work_mbc->ncoll_elems) ++;
#line 906
                        *(work_mbc->coll_elems + tmp___79) = elem;
                      } else {

                      }
                    } else {

                    }
                  }
                }
#line 910
                colon_warning_state |= 8;
#line 913
                while (1) {
#line 913
                  if (! lexleft) {
#line 913
                    tmp___81 = dcgettext((char const   *)((void *)0),
                                         "unbalanced [", 5);
#line 913
                    if ((unsigned long )tmp___81 != (unsigned long )((char *)0)) {
#line 913
                      tmp___80 = dcgettext((char const   *)((void *)0),
                                           "unbalanced [", 5);
#line 913
                      dfaerror((char const   *)tmp___80);
                    } else {
#line 913
                      lasttok = (enum __anonenum_token_32 )-1;
#line 913
                      return (lasttok);
                    }
                  } else {
#line 913
                    tmp___82 = mbrtowc((wchar_t */* __restrict  */)(& _wc___4),
                                       (char const   */* __restrict  */)lexptr,
                                       (unsigned long )lexleft,
                                       (mbstate_t */* __restrict  */)(& mbs));
#line 913
                    cur_mb_len = (int )tmp___82;
#line 913
                    if (cur_mb_len <= 0) {
#line 913
                      cur_mb_len = 1;
#line 913
                      lexleft --;
#line 913
                      tmp___83 = lexptr;
#line 913
                      lexptr ++;
#line 913
                      c1 = (int )((unsigned char )*tmp___83);
#line 913
                      wc1 = (unsigned int )c1;
                    } else {
#line 913
                      lexptr += cur_mb_len;
#line 913
                      lexleft -= cur_mb_len;
#line 913
                      wc1 = (unsigned int )_wc___4;
#line 913
                      tmp___84 = wctob(wc1);
#line 913
                      c1 = (int )tmp___84;
                    }
                  }
#line 913
                  break;
                }
                goto __Cont;
              } else {

              }
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
#line 921
    if (c == 92) {
#line 921
      if (syntax_bits & 1UL) {
#line 922
        while (1) {
#line 922
          if (! lexleft) {
#line 922
            tmp___87 = dcgettext((char const   *)((void *)0), "unbalanced [", 5);
#line 922
            if ((unsigned long )tmp___87 != (unsigned long )((char *)0)) {
#line 922
              tmp___86 = dcgettext((char const   *)((void *)0), "unbalanced [",
                                   5);
#line 922
              dfaerror((char const   *)tmp___86);
            } else {
#line 922
              lasttok = (enum __anonenum_token_32 )-1;
#line 922
              return (lasttok);
            }
          } else {
#line 922
            tmp___88 = mbrtowc((wchar_t */* __restrict  */)(& _wc___5),
                               (char const   */* __restrict  */)lexptr,
                               (unsigned long )lexleft,
                               (mbstate_t */* __restrict  */)(& mbs));
#line 922
            cur_mb_len = (int )tmp___88;
#line 922
            if (cur_mb_len <= 0) {
#line 922
              cur_mb_len = 1;
#line 922
              lexleft --;
#line 922
              tmp___89 = lexptr;
#line 922
              lexptr ++;
#line 922
              c = (int )((unsigned char )*tmp___89);
#line 922
              wc = (unsigned int )c;
            } else {
#line 922
              lexptr += cur_mb_len;
#line 922
              lexleft -= cur_mb_len;
#line 922
              wc = (unsigned int )_wc___5;
#line 922
              tmp___90 = wctob(wc);
#line 922
              c = (int )tmp___90;
            }
          }
#line 922
          break;
        }
      } else {

      }
    } else {

    }
#line 924
    if (c1 == -1) {
#line 925
      while (1) {
#line 925
        if (! lexleft) {
#line 925
          tmp___92 = dcgettext((char const   *)((void *)0), "unbalanced [", 5);
#line 925
          if ((unsigned long )tmp___92 != (unsigned long )((char *)0)) {
#line 925
            tmp___91 = dcgettext((char const   *)((void *)0), "unbalanced [", 5);
#line 925
            dfaerror((char const   *)tmp___91);
          } else {
#line 925
            lasttok = (enum __anonenum_token_32 )-1;
#line 925
            return (lasttok);
          }
        } else {
#line 925
          tmp___93 = mbrtowc((wchar_t */* __restrict  */)(& _wc___6),
                             (char const   */* __restrict  */)lexptr,
                             (unsigned long )lexleft,
                             (mbstate_t */* __restrict  */)(& mbs));
#line 925
          cur_mb_len = (int )tmp___93;
#line 925
          if (cur_mb_len <= 0) {
#line 925
            cur_mb_len = 1;
#line 925
            lexleft --;
#line 925
            tmp___94 = lexptr;
#line 925
            lexptr ++;
#line 925
            c1 = (int )((unsigned char )*tmp___94);
#line 925
            wc1 = (unsigned int )c1;
          } else {
#line 925
            lexptr += cur_mb_len;
#line 925
            lexleft -= cur_mb_len;
#line 925
            wc1 = (unsigned int )_wc___6;
#line 925
            tmp___95 = wctob(wc1);
#line 925
            c1 = (int )tmp___95;
          }
        }
#line 925
        break;
      }
    } else {

    }
#line 927
    if (c1 == 45) {
#line 930
      while (1) {
#line 930
        if (! lexleft) {
#line 930
          tmp___97 = dcgettext((char const   *)((void *)0), "unbalanced [", 5);
#line 930
          if ((unsigned long )tmp___97 != (unsigned long )((char *)0)) {
#line 930
            tmp___96 = dcgettext((char const   *)((void *)0), "unbalanced [", 5);
#line 930
            dfaerror((char const   *)tmp___96);
          } else {
#line 930
            lasttok = (enum __anonenum_token_32 )-1;
#line 930
            return (lasttok);
          }
        } else {
#line 930
          tmp___98 = mbrtowc((wchar_t */* __restrict  */)(& _wc___7),
                             (char const   */* __restrict  */)lexptr,
                             (unsigned long )lexleft,
                             (mbstate_t */* __restrict  */)(& mbs));
#line 930
          cur_mb_len = (int )tmp___98;
#line 930
          if (cur_mb_len <= 0) {
#line 930
            cur_mb_len = 1;
#line 930
            lexleft --;
#line 930
            tmp___99 = lexptr;
#line 930
            lexptr ++;
#line 930
            c2 = (int )((unsigned char )*tmp___99);
#line 930
            wc2 = (unsigned int )c2;
          } else {
#line 930
            lexptr += cur_mb_len;
#line 930
            lexleft -= cur_mb_len;
#line 930
            wc2 = (unsigned int )_wc___7;
#line 930
            tmp___100 = wctob(wc2);
#line 930
            c2 = (int )tmp___100;
          }
        }
#line 930
        break;
      }
#line 931
      if (c2 == 93) {
#line 935
        lexptr -= cur_mb_len;
#line 936
        lexleft += cur_mb_len;
      } else {

      }
    } else {

    }
#line 940
    if (c1 == 45) {
#line 940
      if (c2 != 93) {
#line 942
        if (c2 == 92) {
#line 942
          if (syntax_bits & 1UL) {
#line 944
            while (1) {
#line 944
              if (! lexleft) {
#line 944
                tmp___102 = dcgettext((char const   *)((void *)0),
                                      "unbalanced [", 5);
#line 944
                if ((unsigned long )tmp___102 != (unsigned long )((char *)0)) {
#line 944
                  tmp___101 = dcgettext((char const   *)((void *)0),
                                        "unbalanced [", 5);
#line 944
                  dfaerror((char const   *)tmp___101);
                } else {
#line 944
                  lasttok = (enum __anonenum_token_32 )-1;
#line 944
                  return (lasttok);
                }
              } else {
#line 944
                tmp___103 = mbrtowc((wchar_t */* __restrict  */)(& _wc___8),
                                    (char const   */* __restrict  */)lexptr,
                                    (unsigned long )lexleft,
                                    (mbstate_t */* __restrict  */)(& mbs));
#line 944
                cur_mb_len = (int )tmp___103;
#line 944
                if (cur_mb_len <= 0) {
#line 944
                  cur_mb_len = 1;
#line 944
                  lexleft --;
#line 944
                  tmp___104 = lexptr;
#line 944
                  lexptr ++;
#line 944
                  c2 = (int )((unsigned char )*tmp___104);
#line 944
                  wc2 = (unsigned int )c2;
                } else {
#line 944
                  lexptr += cur_mb_len;
#line 944
                  lexleft -= cur_mb_len;
#line 944
                  wc2 = (unsigned int )_wc___8;
#line 944
                  tmp___105 = wctob(wc2);
#line 944
                  c2 = (int )tmp___105;
                }
              }
#line 944
              break;
            }
          } else {

          }
        } else {

        }
#line 947
        tmp___125 = __ctype_get_mb_cur_max();
#line 947
        if (tmp___125 > 1UL) {
#line 951
          if (range_sts_al == 0) {
#line 953
            if (sizeof(wchar_t ) == 1UL) {
#line 953
              range_sts_al ++;
#line 953
              tmp___106 = xmalloc((unsigned long )range_sts_al);
#line 953
              tmp___108 = tmp___106;
            } else {
#line 953
              range_sts_al ++;
#line 953
              tmp___107 = xnmalloc((unsigned long )range_sts_al,
                                   sizeof(wchar_t ));
#line 953
              tmp___108 = tmp___107;
            }
#line 953
            work_mbc->range_sts = (wchar_t *)tmp___108;
#line 954
            if (sizeof(wchar_t ) == 1UL) {
#line 954
              range_ends_al ++;
#line 954
              tmp___109 = xmalloc((unsigned long )range_ends_al);
#line 954
              tmp___111 = tmp___109;
            } else {
#line 954
              range_ends_al ++;
#line 954
              tmp___110 = xnmalloc((unsigned long )range_ends_al,
                                   sizeof(wchar_t ));
#line 954
              tmp___111 = tmp___110;
            }
#line 954
            work_mbc->range_ends = (wchar_t *)tmp___111;
          } else {

          }
#line 956
          while (1) {
#line 956
            if (range_sts_al <= work_mbc->nranges + 1) {
#line 956
              new_nalloc___3 = (unsigned long )((work_mbc->nranges + 1) + ! work_mbc->range_sts);
#line 956
              tmp___112 = x2nrealloc((void *)work_mbc->range_sts,
                                     & new_nalloc___3, sizeof(wchar_t ));
#line 956
              work_mbc->range_sts = (wchar_t *)tmp___112;
#line 956
              range_sts_al = (int )new_nalloc___3;
            } else {

            }
#line 956
            break;
          }
#line 958
          while (1) {
#line 958
            if (range_ends_al <= work_mbc->nranges + 1) {
#line 958
              new_nalloc___4 = (unsigned long )((work_mbc->nranges + 1) + ! work_mbc->range_ends);
#line 958
              tmp___113 = x2nrealloc((void *)work_mbc->range_ends,
                                     & new_nalloc___4, sizeof(wchar_t ));
#line 958
              work_mbc->range_ends = (wchar_t *)tmp___113;
#line 958
              range_ends_al = (int )new_nalloc___4;
            } else {

            }
#line 958
            break;
          }
#line 960
          if (case_fold) {
#line 960
            tmp___114 = towlower(wc);
#line 960
            *(work_mbc->range_sts + work_mbc->nranges) = (int )tmp___114;
          } else {
#line 960
            *(work_mbc->range_sts + work_mbc->nranges) = (int )wc;
          }
#line 962
          tmp___115 = work_mbc->nranges;
#line 962
          (work_mbc->nranges) ++;
#line 962
          if (case_fold) {
#line 962
            tmp___116 = towlower(wc2);
#line 962
            *(work_mbc->range_ends + tmp___115) = (int )tmp___116;
          } else {
#line 962
            *(work_mbc->range_ends + tmp___115) = (int )wc2;
          }
        } else {
#line 980
          c1 = c;
#line 981
          if (case_fold) {
#line 983
            if (sizeof(c1) > 1UL) {
#line 983
              tmp___118 = tolower(c1);
#line 983
              __res = (int )tmp___118;
            } else {
#line 983
              tmp___119 = __ctype_tolower_loc();
#line 983
              __res = (int )*(*tmp___119 + c1);
            }
#line 983
            c1 = __res;
#line 984
            if (sizeof(c2) > 1UL) {
#line 984
              tmp___121 = tolower(c2);
#line 984
              __res___0 = (int )tmp___121;
            } else {
#line 984
              tmp___122 = __ctype_tolower_loc();
#line 984
              __res___0 = (int )*(*tmp___122 + c2);
            }
#line 984
            c2 = __res___0;
          } else {

          }
#line 986
          if (! hard_LC_COLLATE) {
#line 987
            c = c1;
#line 987
            while (c <= c2) {
#line 988
              setbit_case_fold_c(c, ccl);
#line 987
              c ++;
            }
          } else {
#line 994
            pattern[0] = (char )'[';
#line 994
            pattern[1] = (char )c1;
#line 994
            pattern[2] = (char )'-';
#line 994
            pattern[3] = (char )c2;
#line 994
            pattern[4] = (char )']';
#line 994
            pattern[5] = (char)0;
#line 995
            subject[0] = (char)0;
#line 995
            subject[1] = (char)0;
#line 996
            regcomp((regex_t */* __restrict  */)(& re),
                    (char const   */* __restrict  */)(pattern), 1 << 3);
#line 997
            c = 0;
#line 997
            while (c < 1 << 8) {
#line 999
              subject[0] = (char )c;
#line 1000
              if (case_fold) {
#line 1000
                tmp___123 = __ctype_b_loc();
#line 1000
                if (! ((int const   )*(*tmp___123 + c) & 256)) {
                  goto _L___11;
                } else {

                }
              } else {
                _L___11: 
#line 1000
                tmp___124 = regexec((regex_t const   */* __restrict  */)(& re),
                                    (char const   */* __restrict  */)(subject),
                                    0UL,
                                    (regmatch_t */* __restrict  */)((void *)0),
                                    0);
#line 1000
                if (tmp___124 != 1) {
#line 1002
                  setbit_case_fold_c(c, ccl);
                } else {

                }
              }
#line 997
              c ++;
            }
#line 1004
            regfree(& re);
          }
        }
#line 1008
        colon_warning_state |= 8;
#line 1009
        while (1) {
#line 1009
          if (! lexleft) {
#line 1009
            tmp___127 = dcgettext((char const   *)((void *)0), "unbalanced [", 5);
#line 1009
            if ((unsigned long )tmp___127 != (unsigned long )((char *)0)) {
#line 1009
              tmp___126 = dcgettext((char const   *)((void *)0), "unbalanced [",
                                    5);
#line 1009
              dfaerror((char const   *)tmp___126);
            } else {
#line 1009
              lasttok = (enum __anonenum_token_32 )-1;
#line 1009
              return (lasttok);
            }
          } else {
#line 1009
            tmp___128 = mbrtowc((wchar_t */* __restrict  */)(& _wc___9),
                                (char const   */* __restrict  */)lexptr,
                                (unsigned long )lexleft,
                                (mbstate_t */* __restrict  */)(& mbs));
#line 1009
            cur_mb_len = (int )tmp___128;
#line 1009
            if (cur_mb_len <= 0) {
#line 1009
              cur_mb_len = 1;
#line 1009
              lexleft --;
#line 1009
              tmp___129 = lexptr;
#line 1009
              lexptr ++;
#line 1009
              c1 = (int )((unsigned char )*tmp___129);
#line 1009
              wc1 = (unsigned int )c1;
            } else {
#line 1009
              lexptr += cur_mb_len;
#line 1009
              lexleft -= cur_mb_len;
#line 1009
              wc1 = (unsigned int )_wc___9;
#line 1009
              tmp___130 = wctob(wc1);
#line 1009
              c1 = (int )tmp___130;
            }
          }
#line 1009
          break;
        }
        goto __Cont;
      } else {

      }
    } else {

    }
#line 1013
    if (c == 58) {
#line 1013
      tmp___131 = 2;
    } else {
#line 1013
      tmp___131 = 4;
    }
#line 1013
    colon_warning_state |= tmp___131;
#line 1016
    tmp___139 = __ctype_get_mb_cur_max();
#line 1016
    if (tmp___139 > 1UL) {
#line 1018
      if (case_fold) {
#line 1018
        tmp___135 = iswalpha(wc);
#line 1018
        if (tmp___135) {
#line 1020
          wc = towlower(wc);
#line 1021
          tmp___134 = setbit_wc(wc, ccl);
#line 1021
          if (! tmp___134) {
#line 1023
            while (1) {
#line 1023
              if (chars_al <= work_mbc->nchars + 1) {
#line 1023
                new_nalloc___5 = (unsigned long )((work_mbc->nchars + 1) + ! work_mbc->chars);
#line 1023
                tmp___132 = x2nrealloc((void *)work_mbc->chars,
                                       & new_nalloc___5, sizeof(wchar_t ));
#line 1023
                work_mbc->chars = (wchar_t *)tmp___132;
#line 1023
                chars_al = (int )new_nalloc___5;
              } else {

              }
#line 1023
              break;
            }
#line 1025
            tmp___133 = work_mbc->nchars;
#line 1025
            (work_mbc->nchars) ++;
#line 1025
            *(work_mbc->chars + tmp___133) = (int )wc;
          } else {

          }
          goto __Cont;
        } else {

        }
      } else {

      }
#line 1033
      tmp___138 = setbit_wc(wc, ccl);
#line 1033
      if (! tmp___138) {
#line 1035
        while (1) {
#line 1035
          if (chars_al <= work_mbc->nchars + 1) {
#line 1035
            new_nalloc___6 = (unsigned long )((work_mbc->nchars + 1) + ! work_mbc->chars);
#line 1035
            tmp___136 = x2nrealloc((void *)work_mbc->chars, & new_nalloc___6,
                                   sizeof(wchar_t ));
#line 1035
            work_mbc->chars = (wchar_t *)tmp___136;
#line 1035
            chars_al = (int )new_nalloc___6;
          } else {

          }
#line 1035
          break;
        }
#line 1037
        tmp___137 = work_mbc->nchars;
#line 1037
        (work_mbc->nchars) ++;
#line 1037
        *(work_mbc->chars + tmp___137) = (int )wc;
      } else {

      }
    } else {
#line 1042
      setbit_case_fold_c(c, ccl);
    }
    __Cont: 
#line 809
    wc = wc1;
#line 809
    c = c1;
#line 809
    if (! (c != 93)) {
#line 809
      break;
    } else {

    }
  }
   1495: /* CIL Label */ 
#line 1050
  if (colon_warning_state == 7) {
#line 1051
    tmp___140 = dcgettext((char const   *)((void *)0),
                          "character class syntax is [[:space:]], not [:space:]",
                          5);
#line 1051
    dfawarn((char const   *)tmp___140);
  } else {

  }
   1496: /* CIL Label */ 
#line 1054
  tmp___144 = __ctype_get_mb_cur_max();
   1497: /* CIL Label */ 
#line 1054
  if (tmp___144 > 1UL) {
#line 1057
    work_mbc->invert = invert;
#line 1058
    tmp___143 = equal(ccl, zeroclass);
#line 1058
    if (tmp___143) {
#line 1058
      work_mbc->cset = -1;
    } else {
#line 1058
      tmp___142 = charclass_index(ccl);
#line 1058
      work_mbc->cset = tmp___142;
    }
#line 1059
    return ((enum __anonenum_token_32 )273);
  } else {

  }
   1498: /* CIL Label */ 
#line 1063
  if (invert) {
#line 1066
    tmp___145 = __ctype_get_mb_cur_max();
#line 1066
    if (! (tmp___145 == 1UL)) {
#line 1066
      __assert_fail("(__ctype_get_mb_cur_max ()) == 1", "dfa.c", 1066U,
                    "parse_bracket_exp");
    } else {

    }
#line 1068
    notset(ccl);
#line 1069
    if (syntax_bits & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1070
      clrbit((unsigned int )eolbyte, ccl);
    } else {

    }
  } else {

  }
   1499: /* CIL Label */ 
#line 1073
  tmp___146 = charclass_index(ccl);
   1500: /* CIL Label */ 
#line 1073
  return ((enum __anonenum_token_32 )(275 + tmp___146));
}
}

cilRep: liveness failure for parse_bracket_exp: Errormsg.Error
Bug: BF(Liveness): stmtStartData is not initialized for -1: normal_char: 
#line 1378
laststart = 0;
#line 1382
tmp___50 = __ctype_get_mb_cur_max();
Liveness failed on function:
 static token lex(void) 
{ unsigned int c ;
  unsigned int c2 ;
  int backslash ;
  charclass ccl ;
  int i ;
  wchar_t _wc ;
  size_t tmp ;
  char const   *tmp___0 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___1 ;
  wint_t wc ;
  wchar_t _wc___0 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int lo ;
  int hi ;
  char const   *p ;
  char const   *lim ;
  int tmp___13 ;
  int tmp___14 ;
  wint_t wc___0 ;
  char *tmp___15 ;
  char *tmp___16 ;
  wchar_t _wc___1 ;
  size_t tmp___17 ;
  char const   *tmp___18 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___19 ;
  wint_t wc___1 ;
  char *tmp___20 ;
  char *tmp___21 ;
  wchar_t _wc___2 ;
  size_t tmp___22 ;
  char const   *tmp___23 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___24 ;
  char *tmp___25 ;
  wint_t wc___2 ;
  char *tmp___26 ;
  char *tmp___27 ;
  wchar_t _wc___3 ;
  size_t tmp___28 ;
  char const   *tmp___29 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___30 ;
  wint_t wc___3 ;
  char *tmp___31 ;
  char *tmp___32 ;
  wchar_t _wc___4 ;
  size_t tmp___33 ;
  char const   *tmp___34 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  wint_t wc___4 ;
  char *tmp___38 ;
  char *tmp___39 ;
  wchar_t _wc___5 ;
  size_t tmp___40 ;
  char const   *tmp___41 ;
  int __attribute__((__leaf__, __gnu_inline__))  tmp___42 ;
  char *tmp___43 ;
  size_t tmp___44 ;
  int tmp___45 ;
  unsigned short const   **tmp___46 ;
  int tmp___47 ;
  unsigned short const   **tmp___48 ;
  int tmp___49 ;
  size_t tmp___50 ;
  int tmp___51 ;
  unsigned short const   **tmp___52 ;

  {
   2049: /* CIL Label */ 
#line 1083
  backslash = 0;
   2050: /* CIL Label */ 
#line 1093
  i = 0;
   2051: /* CIL Label */ 
#line 1093
  while (i < 2) {
#line 1096
    tmp___5 = __ctype_get_mb_cur_max();
#line 1096
    if (tmp___5 > 1UL) {
#line 1098
      while (1) {
#line 1098
        if (! lexleft) {
#line 1098
          if ((unsigned long )((void *)0) != (unsigned long )((void *)0)) {
#line 1098
            dfaerror((char const   *)((void *)0));
          } else {
#line 1098
            lasttok = (enum __anonenum_token_32 )-1;
#line 1098
            return (lasttok);
          }
        } else {
#line 1098
          tmp = mbrtowc((wchar_t */* __restrict  */)(& _wc),
                        (char const   */* __restrict  */)lexptr,
                        (unsigned long )lexleft,
                        (mbstate_t */* __restrict  */)(& mbs));
#line 1098
          cur_mb_len = (int )tmp;
#line 1098
          if (cur_mb_len <= 0) {
#line 1098
            cur_mb_len = 1;
#line 1098
            lexleft --;
#line 1098
            tmp___0 = lexptr;
#line 1098
            lexptr ++;
#line 1098
            c = (unsigned int )((unsigned char )*tmp___0);
#line 1098
            wctok = (int )c;
          } else {
#line 1098
            lexptr += cur_mb_len;
#line 1098
            lexleft -= cur_mb_len;
#line 1098
            wctok = _wc;
#line 1098
            tmp___1 = wctob((unsigned int )wctok);
#line 1098
            c = (unsigned int )tmp___1;
          }
        }
#line 1098
        break;
      }
#line 1099
      if ((int )c == -1) {
        goto normal_char;
      } else {

      }
    } else {
#line 1104
      while (1) {
#line 1104
        while (1) {
#line 1104
          if (! lexleft) {
#line 1104
            if ((unsigned long )((void *)0) != (unsigned long )((void *)0)) {
#line 1104
              dfaerror((char const   *)((void *)0));
            } else {
#line 1104
              lasttok = (enum __anonenum_token_32 )-1;
#line 1104
              return (lasttok);
            }
          } else {
#line 1104
            tmp___2 = mbrtowc((wchar_t */* __restrict  */)(& _wc___0),
                              (char const   */* __restrict  */)lexptr,
                              (unsigned long )lexleft,
                              (mbstate_t */* __restrict  */)(& mbs));
#line 1104
            cur_mb_len = (int )tmp___2;
#line 1104
            if (cur_mb_len <= 0) {
#line 1104
              cur_mb_len = 1;
#line 1104
              lexleft --;
#line 1104
              tmp___3 = lexptr;
#line 1104
              lexptr ++;
#line 1104
              c = (unsigned int )((unsigned char )*tmp___3);
#line 1104
              wc = c;
            } else {
#line 1104
              lexptr += cur_mb_len;
#line 1104
              lexleft -= cur_mb_len;
#line 1104
              wc = (unsigned int )_wc___0;
#line 1104
              tmp___4 = wctob(wc);
#line 1104
              c = (unsigned int )tmp___4;
            }
          }
#line 1104
          break;
        }
#line 1104
        break;
      }
    }
#line 1106
    switch ((int )c) {
    case 92: 
#line 1109
    if (backslash) {
      goto normal_char;
    } else {

    }
#line 1111
    if (lexleft == 0) {
#line 1112
      tmp___6 = dcgettext((char const   *)((void *)0), "unfinished \\ escape", 5);
#line 1112
      dfaerror((char const   *)tmp___6);
    } else {

    }
#line 1113
    backslash = 1;
#line 1114
    break;
    case 94: 
#line 1117
    if (backslash) {
      goto normal_char;
    } else {

    }
#line 1119
    if (syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1123
      lasttok = (enum __anonenum_token_32 )258;
#line 1123
      return (lasttok);
    } else {
#line 1119
      if ((int )lasttok == -1) {
#line 1123
        lasttok = (enum __anonenum_token_32 )258;
#line 1123
        return (lasttok);
      } else {
#line 1119
        if ((int )lasttok == 270) {
#line 1123
          lasttok = (enum __anonenum_token_32 )258;
#line 1123
          return (lasttok);
        } else {
#line 1119
          if ((int )lasttok == 269) {
#line 1123
            lasttok = (enum __anonenum_token_32 )258;
#line 1123
            return (lasttok);
          } else {

          }
        }
      }
    }
    goto normal_char;
    case 36: 
#line 1127
    if (backslash) {
      goto normal_char;
    } else {

    }
#line 1129
    if (syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1139
      lasttok = (enum __anonenum_token_32 )259;
#line 1139
      return (lasttok);
    } else {
#line 1129
      if (lexleft == 0) {
#line 1139
        lasttok = (enum __anonenum_token_32 )259;
#line 1139
        return (lasttok);
      } else {
#line 1129
        if (syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1129
          if (lexleft > 0) {
#line 1129
            if ((int const   )*lexptr == 41) {
#line 1129
              tmp___7 = 1;
            } else {
#line 1129
              tmp___7 = 0;
            }
          } else {
#line 1129
            tmp___7 = 0;
          }
#line 1129
          tmp___9 = tmp___7;
        } else {
#line 1129
          if (lexleft > 1) {
#line 1129
            if ((int const   )*(lexptr + 0) == 92) {
#line 1129
              if ((int const   )*(lexptr + 1) == 41) {
#line 1129
                tmp___8 = 1;
              } else {
#line 1129
                tmp___8 = 0;
              }
            } else {
#line 1129
              tmp___8 = 0;
            }
          } else {
#line 1129
            tmp___8 = 0;
          }
#line 1129
          tmp___9 = tmp___8;
        }
#line 1129
        if (tmp___9) {
#line 1139
          lasttok = (enum __anonenum_token_32 )259;
#line 1139
          return (lasttok);
        } else {
#line 1129
          if (syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1129
            if (lexleft > 0) {
#line 1129
              if ((int const   )*lexptr == 124) {
#line 1129
                tmp___10 = 1;
              } else {
#line 1129
                tmp___10 = 0;
              }
            } else {
#line 1129
              tmp___10 = 0;
            }
#line 1129
            tmp___12 = tmp___10;
          } else {
#line 1129
            if (lexleft > 1) {
#line 1129
              if ((int const   )*(lexptr + 0) == 92) {
#line 1129
                if ((int const   )*(lexptr + 1) == 124) {
#line 1129
                  tmp___11 = 1;
                } else {
#line 1129
                  tmp___11 = 0;
                }
              } else {
#line 1129
                tmp___11 = 0;
              }
            } else {
#line 1129
              tmp___11 = 0;
            }
#line 1129
            tmp___12 = tmp___11;
          }
#line 1129
          if (tmp___12) {
#line 1139
            lasttok = (enum __anonenum_token_32 )259;
#line 1139
            return (lasttok);
          } else {
#line 1129
            if (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1129
              if (lexleft > 0) {
#line 1129
                if ((int const   )*lexptr == 10) {
#line 1139
                  lasttok = (enum __anonenum_token_32 )259;
#line 1139
                  return (lasttok);
                } else {

                }
              } else {

              }
            } else {

            }
          }
        }
      }
    }
    goto normal_char;
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
#line 1151
    if (backslash) {
#line 1151
      if (! (syntax_bits & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1153
        laststart = 0;
#line 1154
        lasttok = (enum __anonenum_token_32 )257;
#line 1154
        return (lasttok);
      } else {

      }
    } else {

    }
    goto normal_char;
    case 96: 
#line 1159
    if (backslash) {
#line 1159
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1160
        lasttok = (enum __anonenum_token_32 )258;
#line 1160
        return (lasttok);
      } else {

      }
    } else {

    }
    goto normal_char;
    case 39: 
#line 1164
    if (backslash) {
#line 1164
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1165
        lasttok = (enum __anonenum_token_32 )259;
#line 1165
        return (lasttok);
      } else {

      }
    } else {

    }
    goto normal_char;
    case 60: 
#line 1169
    if (backslash) {
#line 1169
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1170
        lasttok = (enum __anonenum_token_32 )260;
#line 1170
        return (lasttok);
      } else {

      }
    } else {

    }
    goto normal_char;
    case 62: 
#line 1174
    if (backslash) {
#line 1174
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1175
        lasttok = (enum __anonenum_token_32 )261;
#line 1175
        return (lasttok);
      } else {

      }
    } else {

    }
    goto normal_char;
    case 98: 
#line 1179
    if (backslash) {
#line 1179
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1180
        lasttok = (enum __anonenum_token_32 )262;
#line 1180
        return (lasttok);
      } else {

      }
    } else {

    }
    goto normal_char;
    case 66: 
#line 1184
    if (backslash) {
#line 1184
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1185
        lasttok = (enum __anonenum_token_32 )263;
#line 1185
        return (lasttok);
      } else {

      }
    } else {

    }
    goto normal_char;
    case 63: 
#line 1189
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    } else {

    }
#line 1191
    if (backslash != ((syntax_bits & (1UL << 1)) != 0UL)) {
      goto normal_char;
    } else {

    }
#line 1193
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1193
      if (laststart) {
        goto normal_char;
      } else {

      }
    } else {

    }
#line 1195
    lasttok = (enum __anonenum_token_32 )264;
#line 1195
    return (lasttok);
    case 42: 
#line 1198
    if (backslash) {
      goto normal_char;
    } else {

    }
#line 1200
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1200
      if (laststart) {
        goto normal_char;
      } else {

      }
    } else {

    }
#line 1202
    lasttok = (enum __anonenum_token_32 )265;
#line 1202
    return (lasttok);
    case 43: 
#line 1205
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    } else {

    }
#line 1207
    if (backslash != ((syntax_bits & (1UL << 1)) != 0UL)) {
      goto normal_char;
    } else {

    }
#line 1209
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1209
      if (laststart) {
        goto normal_char;
      } else {

      }
    } else {

    }
#line 1211
    lasttok = (enum __anonenum_token_32 )266;
#line 1211
    return (lasttok);
    case 123: 
#line 1214
    if (! (syntax_bits & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      goto normal_char;
    } else {

    }
#line 1216
    if (backslash != ((syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
      goto normal_char;
    } else {

    }
#line 1218
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1218
      if (laststart) {
        goto normal_char;
      } else {

      }
    } else {

    }
#line 1221
    if (syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1225
      lo = -1;
#line 1225
      hi = -1;
#line 1226
      p = lexptr;
#line 1227
      lim = p + lexleft;
#line 1228
      while (1) {
#line 1228
        if ((unsigned long )p != (unsigned long )lim) {
#line 1228
          if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1228
            break;
          } else {

          }
        } else {
#line 1228
          break;
        }
#line 1229
        if (lo < 0) {
#line 1229
          tmp___13 = 0;
        } else {
#line 1229
          tmp___13 = lo * 10;
        }
#line 1229
        lo = (tmp___13 + (int )*p) - 48;
#line 1228
        p ++;
      }
#line 1230
      if ((unsigned long )p != (unsigned long )lim) {
#line 1230
        if ((int const   )*p == 44) {
#line 1231
          while (1) {
#line 1231
            p ++;
#line 1231
            if ((unsigned long )p != (unsigned long )lim) {
#line 1231
              if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1231
                break;
              } else {

              }
            } else {
#line 1231
              break;
            }
#line 1232
            if (hi < 0) {
#line 1232
              tmp___14 = 0;
            } else {
#line 1232
              tmp___14 = hi * 10;
            }
#line 1232
            hi = (tmp___14 + (int )*p) - 48;
          }
        } else {
#line 1234
          hi = lo;
        }
      } else {
#line 1234
        hi = lo;
      }
#line 1235
      if ((unsigned long )p == (unsigned long )lim) {
        goto normal_char;
      } else {
#line 1235
        if ((int const   )*p != 125) {
          goto normal_char;
        } else {
#line 1235
          if (lo < 0) {
            goto normal_char;
          } else {
#line 1235
            if (32767 < hi) {
              goto normal_char;
            } else {
#line 1235
              if (0 <= hi) {
#line 1235
                if (hi < lo) {
                  goto normal_char;
                } else {

                }
              } else {

              }
            }
          }
        }
      }
    } else {

    }
#line 1240
    minrep = 0;
#line 1245
    while (1) {
#line 1245
      while (1) {
#line 1245
        if (! lexleft) {
#line 1245
          tmp___16 = dcgettext((char const   *)((void *)0),
                               "unfinished repeat count", 5);
#line 1245
          if ((unsigned long )tmp___16 != (unsigned long )((char *)0)) {
#line 1245
            tmp___15 = dcgettext((char const   *)((void *)0),
                                 "unfinished repeat count", 5);
#line 1245
            dfaerror((char const   *)tmp___15);
          } else {
#line 1245
            lasttok = (enum __anonenum_token_32 )-1;
#line 1245
            return (lasttok);
          }
        } else {
#line 1245
          tmp___17 = mbrtowc((wchar_t */* __restrict  */)(& _wc___1),
                             (char const   */* __restrict  */)lexptr,
                             (unsigned long )lexleft,
                             (mbstate_t */* __restrict  */)(& mbs));
#line 1245
          cur_mb_len = (int )tmp___17;
#line 1245
          if (cur_mb_len <= 0) {
#line 1245
            cur_mb_len = 1;
#line 1245
            lexleft --;
#line 1245
            tmp___18 = lexptr;
#line 1245
            lexptr ++;
#line 1245
            c = (unsigned int )((unsigned char )*tmp___18);
#line 1245
            wc___0 = c;
          } else {
#line 1245
            lexptr += cur_mb_len;
#line 1245
            lexleft -= cur_mb_len;
#line 1245
            wc___0 = (unsigned int )_wc___1;
#line 1245
            tmp___19 = wctob(wc___0);
#line 1245
            c = (unsigned int )tmp___19;
          }
        }
#line 1245
        break;
      }
#line 1245
      break;
    }
#line 1246
    if (c - 48U <= 9U) {
#line 1248
      minrep = (int )(c - 48U);
#line 1249
      while (1) {
#line 1251
        while (1) {
#line 1251
          while (1) {
#line 1251
            if (! lexleft) {
#line 1251
              tmp___21 = dcgettext((char const   *)((void *)0),
                                   "unfinished repeat count", 5);
#line 1251
              if ((unsigned long )tmp___21 != (unsigned long )((char *)0)) {
#line 1251
                tmp___20 = dcgettext((char const   *)((void *)0),
                                     "unfinished repeat count", 5);
#line 1251
                dfaerror((char const   *)tmp___20);
              } else {
#line 1251
                lasttok = (enum __anonenum_token_32 )-1;
#line 1251
                return (lasttok);
              }
            } else {
#line 1251
              tmp___22 = mbrtowc((wchar_t */* __restrict  */)(& _wc___2),
                                 (char const   */* __restrict  */)lexptr,
                                 (unsigned long )lexleft,
                                 (mbstate_t */* __restrict  */)(& mbs));
#line 1251
              cur_mb_len = (int )tmp___22;
#line 1251
              if (cur_mb_len <= 0) {
#line 1251
                cur_mb_len = 1;
#line 1251
                lexleft --;
#line 1251
                tmp___23 = lexptr;
#line 1251
                lexptr ++;
#line 1251
                c = (unsigned int )((unsigned char )*tmp___23);
#line 1251
                wc___1 = c;
              } else {
#line 1251
                lexptr += cur_mb_len;
#line 1251
                lexleft -= cur_mb_len;
#line 1251
                wc___1 = (unsigned int )_wc___2;
#line 1251
                tmp___24 = wctob(wc___1);
#line 1251
                c = (unsigned int )tmp___24;
              }
            }
#line 1251
            break;
          }
#line 1251
          break;
        }
#line 1252
        if (! (c - 48U <= 9U)) {
#line 1253
          break;
        } else {

        }
#line 1254
        minrep = (int )(((unsigned int )(10 * minrep) + c) - 48U);
      }
    } else {
#line 1258
      tmp___25 = dcgettext((char const   *)((void *)0),
                           "malformed repeat count", 5);
#line 1258
      dfaerror((char const   *)tmp___25);
    }
#line 1259
    if (c == 44U) {
#line 1261
      while (1) {
#line 1261
        while (1) {
#line 1261
          if (! lexleft) {
#line 1261
            tmp___27 = dcgettext((char const   *)((void *)0),
                                 "unfinished repeat count", 5);
#line 1261
            if ((unsigned long )tmp___27 != (unsigned long )((char *)0)) {
#line 1261
              tmp___26 = dcgettext((char const   *)((void *)0),
                                   "unfinished repeat count", 5);
#line 1261
              dfaerror((char const   *)tmp___26);
            } else {
#line 1261
              lasttok = (enum __anonenum_token_32 )-1;
#line 1261
              return (lasttok);
            }
          } else {
#line 1261
            tmp___28 = mbrtowc((wchar_t */* __restrict  */)(& _wc___3),
                               (char const   */* __restrict  */)lexptr,
                               (unsigned long )lexleft,
                               (mbstate_t */* __restrict  */)(& mbs));
#line 1261
            cur_mb_len = (int )tmp___28;
#line 1261
            if (cur_mb_len <= 0) {
#line 1261
              cur_mb_len = 1;
#line 1261
              lexleft --;
#line 1261
              tmp___29 = lexptr;
#line 1261
              lexptr ++;
#line 1261
              c = (unsigned int )((unsigned char )*tmp___29);
#line 1261
              wc___2 = c;
            } else {
#line 1261
              lexptr += cur_mb_len;
#line 1261
              lexleft -= cur_mb_len;
#line 1261
              wc___2 = (unsigned int )_wc___3;
#line 1261
              tmp___30 = wctob(wc___2);
#line 1261
              c = (unsigned int )tmp___30;
            }
          }
#line 1261
          break;
        }
#line 1261
        break;
      }
#line 1262
      if (! (c - 48U <= 9U)) {
#line 1263
        maxrep = -1;
      } else {
#line 1266
        maxrep = (int )(c - 48U);
#line 1267
        while (1) {
#line 1269
          while (1) {
#line 1269
            while (1) {
#line 1269
              if (! lexleft) {
#line 1269
                tmp___32 = dcgettext((char const   *)((void *)0),
                                     "unfinished repeat count", 5);
#line 1269
                if ((unsigned long )tmp___32 != (unsigned long )((char *)0)) {
#line 1269
                  tmp___31 = dcgettext((char const   *)((void *)0),
                                       "unfinished repeat count", 5);
#line 1269
                  dfaerror((char const   *)tmp___31);
                } else {
#line 1269
                  lasttok = (enum __anonenum_token_32 )-1;
#line 1269
                  return (lasttok);
                }
              } else {
#line 1269
                tmp___33 = mbrtowc((wchar_t */* __restrict  */)(& _wc___4),
                                   (char const   */* __restrict  */)lexptr,
                                   (unsigned long )lexleft,
                                   (mbstate_t */* __restrict  */)(& mbs));
#line 1269
                cur_mb_len = (int )tmp___33;
#line 1269
                if (cur_mb_len <= 0) {
#line 1269
                  cur_mb_len = 1;
#line 1269
                  lexleft --;
#line 1269
                  tmp___34 = lexptr;
#line 1269
                  lexptr ++;
#line 1269
                  c = (unsigned int )((unsigned char )*tmp___34);
#line 1269
                  wc___3 = c;
                } else {
#line 1269
                  lexptr += cur_mb_len;
#line 1269
                  lexleft -= cur_mb_len;
#line 1269
                  wc___3 = (unsigned int )_wc___4;
#line 1269
                  tmp___35 = wctob(wc___3);
#line 1269
                  c = (unsigned int )tmp___35;
                }
              }
#line 1269
              break;
            }
#line 1269
            break;
          }
#line 1270
          if (! (c - 48U <= 9U)) {
#line 1271
            break;
          } else {

          }
#line 1272
          maxrep = (int )(((unsigned int )(10 * maxrep) + c) - 48U);
        }
#line 1274
        if (0 <= maxrep) {
#line 1274
          if (maxrep < minrep) {
#line 1275
            tmp___36 = dcgettext((char const   *)((void *)0),
                                 "malformed repeat count", 5);
#line 1275
            dfaerror((char const   *)tmp___36);
          } else {

          }
        } else {

        }
      }
    } else {
#line 1279
      maxrep = minrep;
    }
#line 1280
    if (! (syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1282
      if (c != 92U) {
#line 1283
        tmp___37 = dcgettext((char const   *)((void *)0),
                             "malformed repeat count", 5);
#line 1283
        dfaerror((char const   *)tmp___37);
      } else {

      }
#line 1284
      while (1) {
#line 1284
        while (1) {
#line 1284
          if (! lexleft) {
#line 1284
            tmp___39 = dcgettext((char const   *)((void *)0),
                                 "unfinished repeat count", 5);
#line 1284
            if ((unsigned long )tmp___39 != (unsigned long )((char *)0)) {
#line 1284
              tmp___38 = dcgettext((char const   *)((void *)0),
                                   "unfinished repeat count", 5);
#line 1284
              dfaerror((char const   *)tmp___38);
            } else {
#line 1284
              lasttok = (enum __anonenum_token_32 )-1;
#line 1284
              return (lasttok);
            }
          } else {
#line 1284
            tmp___40 = mbrtowc((wchar_t */* __restrict  */)(& _wc___5),
                               (char const   */* __restrict  */)lexptr,
                               (unsigned long )lexleft,
                               (mbstate_t */* __restrict  */)(& mbs));
#line 1284
            cur_mb_len = (int )tmp___40;
#line 1284
            if (cur_mb_len <= 0) {
#line 1284
              cur_mb_len = 1;
#line 1284
              lexleft --;
#line 1284
              tmp___41 = lexptr;
#line 1284
              lexptr ++;
#line 1284
              c = (unsigned int )((unsigned char )*tmp___41);
#line 1284
              wc___4 = c;
            } else {
#line 1284
              lexptr += cur_mb_len;
#line 1284
              lexleft -= cur_mb_len;
#line 1284
              wc___4 = (unsigned int )_wc___5;
#line 1284
              tmp___42 = wctob(wc___4);
#line 1284
              c = (unsigned int )tmp___42;
            }
          }
#line 1284
          break;
        }
#line 1284
        break;
      }
    } else {

    }
#line 1286
    if (c != 125U) {
#line 1287
      tmp___43 = dcgettext((char const   *)((void *)0),
                           "malformed repeat count", 5);
#line 1287
      dfaerror((char const   *)tmp___43);
    } else {

    }
#line 1288
    laststart = 0;
#line 1289
    lasttok = (enum __anonenum_token_32 )267;
#line 1289
    return (lasttok);
    case 124: 
#line 1292
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    } else {

    }
#line 1294
    if (backslash != ((syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
      goto normal_char;
    } else {

    }
#line 1296
    laststart = 1;
#line 1297
    lasttok = (enum __anonenum_token_32 )269;
#line 1297
    return (lasttok);
    case 10: 
#line 1300
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    } else {
#line 1300
      if (backslash) {
        goto normal_char;
      } else {
#line 1300
        if (! (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
          goto normal_char;
        } else {

        }
      }
    }
#line 1304
    laststart = 1;
#line 1305
    lasttok = (enum __anonenum_token_32 )269;
#line 1305
    return (lasttok);
    case 40: 
#line 1308
    if (backslash != ((syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
      goto normal_char;
    } else {

    }
#line 1310
    parens ++;
#line 1311
    laststart = 1;
#line 1312
    lasttok = (enum __anonenum_token_32 )270;
#line 1312
    return (lasttok);
    case 41: 
#line 1315
    if (backslash != ((syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
      goto normal_char;
    } else {

    }
#line 1317
    if (parens == 0) {
#line 1317
      if (syntax_bits & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto normal_char;
      } else {

      }
    } else {

    }
#line 1319
    parens --;
#line 1320
    laststart = 0;
#line 1321
    lasttok = (enum __anonenum_token_32 )271;
#line 1321
    return (lasttok);
    case 46: 
#line 1324
    if (backslash) {
      goto normal_char;
    } else {

    }
#line 1327
    tmp___44 = __ctype_get_mb_cur_max();
#line 1327
    if (tmp___44 > 1UL) {
#line 1331
      laststart = 0;
#line 1332
      lasttok = (enum __anonenum_token_32 )272;
#line 1332
      return (lasttok);
    } else {

    }
#line 1335
    zeroset(ccl);
#line 1336
    notset(ccl);
#line 1337
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1338
      clrbit((unsigned int )eolbyte, ccl);
    } else {

    }
#line 1339
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1340
      clrbit((unsigned int )'\000', ccl);
    } else {

    }
#line 1341
    laststart = 0;
#line 1342
    tmp___45 = charclass_index(ccl);
#line 1342
    lasttok = (enum __anonenum_token_32 )(275 + tmp___45);
#line 1342
    return (lasttok);
    case 115: 
    case 83: 
#line 1346
    if (! backslash) {
      goto normal_char;
    } else {
#line 1346
      if (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto normal_char;
      } else {

      }
    }
#line 1348
    zeroset(ccl);
#line 1349
    c2 = 0U;
#line 1349
    while (c2 < (unsigned int )(1 << 8)) {
#line 1350
      tmp___46 = __ctype_b_loc();
#line 1350
      if ((int const   )*(*tmp___46 + (int )c2) & 8192) {
#line 1351
        setbit(c2, ccl);
      } else {

      }
#line 1349
      c2 ++;
    }
#line 1352
    if (c == 83U) {
#line 1353
      notset(ccl);
    } else {

    }
#line 1354
    laststart = 0;
#line 1355
    tmp___47 = charclass_index(ccl);
#line 1355
    lasttok = (enum __anonenum_token_32 )(275 + tmp___47);
#line 1355
    return (lasttok);
    case 119: 
    case 87: 
#line 1359
    if (! backslash) {
      goto normal_char;
    } else {
#line 1359
      if (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto normal_char;
      } else {

      }
    }
#line 1361
    zeroset(ccl);
#line 1362
    c2 = 0U;
#line 1362
    while (c2 < (unsigned int )(1 << 8)) {
#line 1363
      tmp___48 = __ctype_b_loc();
#line 1363
      if ((int const   )*(*tmp___48 + (int )c2) & 8) {
#line 1364
        setbit(c2, ccl);
      } else {
#line 1363
        if (c2 == 95U) {
#line 1364
          setbit(c2, ccl);
        } else {

        }
      }
#line 1362
      c2 ++;
    }
#line 1365
    if (c == 87U) {
#line 1366
      notset(ccl);
    } else {

    }
#line 1367
    laststart = 0;
#line 1368
    tmp___49 = charclass_index(ccl);
#line 1368
    lasttok = (enum __anonenum_token_32 )(275 + tmp___49);
#line 1368
    return (lasttok);
    case 91: 
#line 1371
    if (backslash) {
      goto normal_char;
    } else {

    }
#line 1373
    laststart = 0;
#line 1374
    lasttok = parse_bracket_exp();
#line 1374
    return (lasttok);
    default: ;
    normal_char: 
#line 1378
    laststart = 0;
#line 1382
    tmp___50 = __ctype_get_mb_cur_max();
#line 1382
    if (tmp___50 > 1UL) {
#line 1383
      lasttok = (enum __anonenum_token_32 )274;
#line 1383
      return (lasttok);
    } else {

    }
#line 1386
    if (case_fold) {
#line 1386
      tmp___52 = __ctype_b_loc();
#line 1386
      if ((int const   )*(*tmp___52 + (int )c) & 1024) {
#line 1388
        zeroset(ccl);
#line 1389
        setbit_case_fold_c((int )c, ccl);
#line 1390
        tmp___51 = charclass_index(ccl);
#line 1390
        lasttok = (enum __anonenum_token_32 )(275 + tmp___51);
#line 1390
        return (lasttok);
      } else {

      }
    } else {

    }
#line 1393
    lasttok = (enum __anonenum_token_32 )c;
#line 1393
    return (lasttok);
    }
#line 1093
    i ++;
  }
   2052: /* CIL Label */ 
#line 1399
  abort();
   2053: /* CIL Label */ 
#line 1400
  return ((enum __anonenum_token_32 )-1);
}
}

cilRep: liveness failure for lex: Errormsg.Error
Bug: BF(Liveness): stmtStartData is not initialized for -1: _L: 
#line 1488
addtok_mb((enum __anonenum_token_32 )273, ((dfa->nmbcsets - 1) << 2) + 3);
Liveness failed on function:
 static void addtok(token t ) 
{ _Bool need_or ;
  struct mb_char_classes *work_mbc ;
  int i ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
   2130: /* CIL Label */ 
#line 1459
  tmp___1 = __ctype_get_mb_cur_max();
   2131: /* CIL Label */ 
#line 1459
  if (tmp___1 > 1UL) {
#line 1459
    if ((int )t == 273) {
#line 1461
      need_or = (_Bool)0;
#line 1462
      work_mbc = dfa->mbcsets + (dfa->nmbcsets - 1);
#line 1466
      if (! work_mbc->invert) {
#line 1469
        i = 0;
#line 1469
        while (i < work_mbc->nchars) {
#line 1471
          addtok_wc((unsigned int )*(work_mbc->chars + i));
#line 1472
          if (need_or) {
#line 1473
            addtok((enum __anonenum_token_32 )269);
          } else {

          }
#line 1474
          need_or = (_Bool)1;
#line 1469
          i ++;
        }
#line 1476
        work_mbc->nchars = 0;
      } else {

      }
#line 1480
      if (work_mbc->invert) {
        goto _L;
      } else {
#line 1480
        tmp___0 = using_utf8();
#line 1480
        if (tmp___0) {
          _L___0: 
#line 1480
          if (work_mbc->nchars != 0) {
            goto _L;
          } else {
#line 1480
            if (work_mbc->nch_classes != 0) {
              goto _L;
            } else {
#line 1480
              if (work_mbc->nranges != 0) {
                goto _L;
              } else {
#line 1480
                if (work_mbc->nequivs != 0) {
                  goto _L;
                } else {
#line 1480
                  if (work_mbc->ncoll_elems != 0) {
                    _L: 
#line 1488
                    addtok_mb((enum __anonenum_token_32 )273,
                              ((dfa->nmbcsets - 1) << 2) + 3);
#line 1489
                    if (need_or) {
#line 1490
                      addtok((enum __anonenum_token_32 )269);
                    } else {

                    }
                  } else {
#line 1496
                    if (work_mbc->cset != -1) {
#line 1498
                      tmp = using_utf8();
#line 1498
                      if (! tmp) {
#line 1498
                        __assert_fail("using_utf8 ()", "dfa.c", 1498U, "addtok");
                      } else {

                      }
#line 1499
                      addtok((enum __anonenum_token_32 )(275 + work_mbc->cset));
#line 1500
                      if (need_or) {
#line 1501
                        addtok((enum __anonenum_token_32 )269);
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
            }
          }
        } else {
#line 1480
          if (work_mbc->cset != -1) {
            goto _L;
          } else {
            goto _L___0;
          }
        }
      }
    } else {
#line 1507
      addtok_mb(t, 3);
    }
  } else {
#line 1507
    addtok_mb(t, 3);
  }
   2132: /* CIL Label */ 
#line 1508
  return;
}
}

cilRep: liveness failure for addtok: Errormsg.Error
Bug: BF(Liveness): stmtStartData is not initialized for -1: _L___0: 
#line 1730
ntokens = nsubtoks(dfa->tindex);
#line 1731
tindex = dfa->tindex - ntokens;
Liveness failed on function:
 static void closure(void) 
{ int tindex ;
  int ntokens ;
  int i ;
  int tmp ;

  {
   2309: /* CIL Label */ 
#line 1726
  atom();
   2310: /* CIL Label */ 
#line 1727
  while (1) {
#line 1727
    if (! ((int )tok == 264)) {
#line 1727
      if (! ((int )tok == 265)) {
#line 1727
        if (! ((int )tok == 266)) {
#line 1727
          if (! ((int )tok == 267)) {
#line 1727
            break;
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
#line 1728
    if ((int )tok == 267) {
#line 1728
      if (minrep) {
        goto _L___0;
      } else {
#line 1728
        if (maxrep) {
          _L___0: 
#line 1730
          ntokens = nsubtoks(dfa->tindex);
#line 1731
          tindex = dfa->tindex - ntokens;
#line 1732
          if (maxrep < 0) {
#line 1733
            addtok((enum __anonenum_token_32 )266);
          } else {

          }
#line 1734
          if (minrep == 0) {
#line 1735
            addtok((enum __anonenum_token_32 )264);
          } else {

          }
#line 1736
          i = 1;
#line 1736
          while (i < minrep) {
#line 1738
            copytoks(tindex, ntokens);
#line 1739
            addtok((enum __anonenum_token_32 )268);
#line 1736
            i ++;
          }
#line 1741
          while (i < maxrep) {
#line 1743
            copytoks(tindex, ntokens);
#line 1744
            addtok((enum __anonenum_token_32 )264);
#line 1745
            addtok((enum __anonenum_token_32 )268);
#line 1741
            i ++;
          }
#line 1747
          tok = lex();
        } else {
          goto _L;
        }
      }
    } else {
      _L: 
#line 1749
      if ((int )tok == 267) {
#line 1751
        tmp = nsubtoks(dfa->tindex);
#line 1751
        dfa->tindex -= tmp;
#line 1752
        tok = lex();
#line 1753
        closure();
      } else {
#line 1757
        addtok(tok);
#line 1758
        tok = lex();
      }
    }
  }
   2311: /* CIL Label */ 
#line 1760
  return;
}
}

cilRep: liveness failure for closure: Errormsg.Error
Bug: BF(Liveness): stmtStartData is not initialized for -1: _L: 
#line 1861
i = count;
Liveness failed on function:
 static void insert(position p , position_set *s ) 
{ int count ;
  int lo ;
  int hi ;
  int mid ;
  int i ;

  {
   2380: /* CIL Label */ 
#line 1845
  count = s->nelem;
   2381: /* CIL Label */ 
#line 1846
  lo = 0;
   2382: /* CIL Label */ 
#line 1846
  hi = count;
   2383: /* CIL Label */ 
#line 1847
  while (lo < hi) {
#line 1849
    mid = (int )(((unsigned int )lo + (unsigned int )hi) >> 1);
#line 1850
    if ((s->elems + mid)->index < p.index) {
#line 1851
      lo = mid + 1;
    } else {
#line 1853
      hi = mid;
    }
  }
   2384: /* CIL Label */ 
#line 1856
  if (lo < count) {
#line 1856
    if (p.index == (s->elems + lo)->index) {
#line 1857
      (s->elems + lo)->constraint |= p.constraint;
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 1861
    i = count;
#line 1861
    while (i > lo) {
#line 1862
      *(s->elems + i) = *(s->elems + (i - 1));
#line 1861
      i --;
    }
#line 1863
    *(s->elems + lo) = p;
#line 1864
    (s->nelem) ++;
  }
   2385: /* CIL Label */ 
#line 1866
  return;
}
}

cilRep: liveness failure for insert: Errormsg.Error
Bug: BF(Liveness): stmtStartData is not initialized for -1: __Cont: 
#line 1924
i ++;
Liveness failed on function:
 static int state_index(struct dfa *d , position_set const   *s , int newline ,
                        int letter ) 
{ int hash ;
  int constraint ;
  int i ;
  int j ;
  size_t new_nalloc ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
   2540: /* CIL Label */ 
#line 1913
  hash = 0;
   2541: /* CIL Label */ 
#line 1917
  if (newline) {
#line 1917
    newline = 1;
  } else {
#line 1917
    newline = 0;
  }
   2542: /* CIL Label */ 
#line 1918
  if (letter) {
#line 1918
    letter = 1;
  } else {
#line 1918
    letter = 0;
  }
   2543: /* CIL Label */ 
#line 1920
  i = 0;
   2544: /* CIL Label */ 
#line 1920
  while (i < (int )s->nelem) {
#line 1921
    hash = (int )((unsigned int )hash ^ ((s->elems + i)->index + (s->elems + i)->constraint));
#line 1920
    i ++;
  }
   2545: /* CIL Label */ 
#line 1924
  i = 0;
   2546: /* CIL Label */ 
#line 1924
  while (i < d->sindex) {
#line 1926
    if (hash != (d->states + i)->hash) {
      goto __Cont;
    } else {
#line 1926
      if (s->nelem != (int const   )(d->states + i)->elems.nelem) {
        goto __Cont;
      } else {
#line 1926
        if (newline != (int )(d->states + i)->newline) {
          goto __Cont;
        } else {
#line 1926
          if (letter != (int )(d->states + i)->letter) {
            goto __Cont;
          } else {

          }
        }
      }
    }
#line 1929
    j = 0;
#line 1929
    while (j < (int )s->nelem) {
#line 1930
      if ((s->elems + j)->constraint != ((d->states + i)->elems.elems + j)->constraint) {
#line 1933
        break;
      } else {
#line 1930
        if ((s->elems + j)->index != ((d->states + i)->elems.elems + j)->index) {
#line 1933
          break;
        } else {

        }
      }
#line 1929
      j ++;
    }
#line 1934
    if (j == (int )s->nelem) {
#line 1935
      return (i);
    } else {

    }
    __Cont: 
#line 1924
    i ++;
  }
   2547: /* CIL Label */ 
#line 1939
  while (1) {
#line 1939
    if (d->salloc <= d->sindex) {
#line 1939
      new_nalloc = (unsigned long )(d->sindex + ! d->states);
#line 1939
      tmp = x2nrealloc((void *)d->states, & new_nalloc, sizeof(dfa_state ));
#line 1939
      d->states = (dfa_state *)tmp;
#line 1939
      d->salloc = (int )new_nalloc;
    } else {

    }
#line 1939
    break;
  }
   2548: /* CIL Label */ 
#line 1940
  (d->states + i)->hash = hash;
   2549: /* CIL Label */ 
#line 1941
  if (sizeof(position ) == 1UL) {
#line 1941
    tmp___0 = xmalloc((unsigned long )s->nelem);
#line 1941
    tmp___2 = tmp___0;
  } else {
#line 1941
    tmp___1 = xnmalloc((unsigned long )s->nelem, sizeof(position ));
#line 1941
    tmp___2 = tmp___1;
  }
   2550: /* CIL Label */ 
#line 1941
  (d->states + i)->elems.elems = (position *)tmp___2;
   2551: /* CIL Label */ 
#line 1942
  copy(s, & (d->states + i)->elems);
   2552: /* CIL Label */ 
#line 1943
  (d->states + i)->newline = (char )newline;
   2553: /* CIL Label */ 
#line 1944
  (d->states + i)->letter = (char )letter;
   2554: /* CIL Label */ 
#line 1945
  (d->states + i)->backref = (char)0;
   2555: /* CIL Label */ 
#line 1946
  (d->states + i)->constraint = (unsigned char)0;
   2556: /* CIL Label */ 
#line 1947
  (d->states + i)->first_end = 0;
   2557: /* CIL Label */ 
#line 1949
  (d->states + i)->mbps.nelem = 0;
   2558: /* CIL Label */ 
#line 1950
  (d->states + i)->mbps.elems = (position *)((void *)0);
   2559: /* CIL Label */ 
#line 1952
  j = 0;
   2560: /* CIL Label */ 
#line 1952
  while (j < (int )s->nelem) {
#line 1953
    if ((int )*(d->tokens + (s->elems + j)->index) < 0) {
#line 1955
      constraint = (int )(s->elems + j)->constraint;
#line 1956
      if (newline) {
#line 1956
        tmp___3 = 2;
      } else {
#line 1956
        tmp___3 = 0;
      }
#line 1956
      if (constraint & (1 << (tmp___3 + 4))) {
#line 1956
        if (letter) {
#line 1956
          tmp___4 = 2;
        } else {
#line 1956
          tmp___4 = 0;
        }
#line 1956
        if (constraint & (1 << tmp___4)) {
#line 1960
          (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
#line 1956
        if (newline) {
#line 1956
          tmp___5 = 2;
        } else {
#line 1956
          tmp___5 = 0;
        }
#line 1956
        if (constraint & (1 << (tmp___5 + 4))) {
#line 1956
          if (letter) {
#line 1956
            tmp___6 = 2;
          } else {
#line 1956
            tmp___6 = 0;
          }
#line 1956
          if (constraint & (1 << (tmp___6 + 1))) {
#line 1960
            (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
          } else {
            goto _L___0;
          }
        } else {
          _L___0: 
#line 1956
          if (newline) {
#line 1956
            tmp___7 = 2;
          } else {
#line 1956
            tmp___7 = 0;
          }
#line 1956
          if (constraint & (1 << ((tmp___7 + 1) + 4))) {
#line 1956
            if (letter) {
#line 1956
              tmp___8 = 2;
            } else {
#line 1956
              tmp___8 = 0;
            }
#line 1956
            if (constraint & (1 << tmp___8)) {
#line 1960
              (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
            } else {
              goto _L;
            }
          } else {
            _L: 
#line 1956
            if (newline) {
#line 1956
              tmp___9 = 2;
            } else {
#line 1956
              tmp___9 = 0;
            }
#line 1956
            if (constraint & (1 << ((tmp___9 + 1) + 4))) {
#line 1956
              if (letter) {
#line 1956
                tmp___10 = 2;
              } else {
#line 1956
                tmp___10 = 0;
              }
#line 1956
              if (constraint & (1 << (tmp___10 + 1))) {
#line 1960
                (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
              } else {

              }
            } else {

            }
          }
        }
      }
#line 1961
      if (! (d->states + i)->first_end) {
#line 1962
        (d->states + i)->first_end = (int )*(d->tokens + (s->elems + j)->index);
      } else {

      }
    } else {
#line 1964
      if ((int )*(d->tokens + (s->elems + j)->index) == 257) {
#line 1966
        (d->states + i)->constraint = (unsigned char)255;
#line 1967
        (d->states + i)->backref = (char)1;
      } else {

      }
    }
#line 1952
    j ++;
  }
   2561: /* CIL Label */ 
#line 1970
  (d->sindex) ++;
   2562: /* CIL Label */ 
#line 1972
  return (i);
}
}

cilRep: liveness failure for state_index: Errormsg.Error
Bug: BF(Liveness): stmtStartData is not initialized for -1: __Cont: 
#line 1989
i ++;
Liveness failed on function:
 static void epsclosure(position_set *s , struct dfa  const  *d ) 
{ int i ;
  int j ;
  char *visited ;
  position p ;
  position old ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
   2603: /* CIL Label */ 
#line 1987
  if (sizeof(char ) == 1UL) {
#line 1987
    tmp = xzalloc((unsigned long )d->tindex);
#line 1987
    tmp___1 = tmp;
  } else {
#line 1987
    tmp___0 = xcalloc((unsigned long )d->tindex, sizeof(char ));
#line 1987
    tmp___1 = tmp___0;
  }
   2604: /* CIL Label */ 
#line 1987
  visited = (char *)tmp___1;
   2605: /* CIL Label */ 
#line 1989
  i = 0;
   2606: /* CIL Label */ 
#line 1989
  while (i < s->nelem) {
#line 1990
    if ((int )*(d->tokens + (s->elems + i)->index) >= 1 << 8) {
#line 1990
      if ((int )*(d->tokens + (s->elems + i)->index) != 257) {
#line 1990
        if ((int )*(d->tokens + (s->elems + i)->index) != 272) {
#line 1990
          if ((int )*(d->tokens + (s->elems + i)->index) != 273) {
#line 1990
            if ((int )*(d->tokens + (s->elems + i)->index) < 275) {
#line 1998
              old = *(s->elems + i);
#line 1999
              p.constraint = old.constraint;
#line 2000
              delete(*(s->elems + i), s);
#line 2001
              if (*(visited + old.index)) {
#line 2003
                i --;
                goto __Cont;
              } else {

              }
#line 2006
              *(visited + old.index) = (char)1;
#line 2007
              switch ((int )*(d->tokens + old.index)) {
              case 258: 
#line 2010
              p.constraint &= 207U;
#line 2011
              break;
              case 259: 
#line 2013
              p.constraint &= 175U;
#line 2014
              break;
              case 260: 
#line 2016
              p.constraint &= 242U;
#line 2017
              break;
              case 261: 
#line 2019
              p.constraint &= 244U;
#line 2020
              break;
              case 262: 
#line 2022
              p.constraint &= 246U;
#line 2023
              break;
              case 263: 
#line 2025
              p.constraint &= 249U;
#line 2026
              break;
              default: ;
#line 2028
              break;
              }
#line 2030
              j = 0;
#line 2030
              while (j < (d->follows + old.index)->nelem) {
#line 2032
                p.index = ((d->follows + old.index)->elems + j)->index;
#line 2033
                insert(p, s);
#line 2030
                j ++;
              }
#line 2036
              i = -1;
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    __Cont: 
#line 1989
    i ++;
  }
   2607: /* CIL Label */ 
#line 2039
  free((void *)visited);
   2608: /* CIL Label */ 
#line 2040
  return;
}
}

cilRep: liveness failure for epsclosure: Errormsg.Error
Bug: BF(Liveness): stmtStartData is not initialized for -1: _L: 
#line 2291
copy((position_set const   *)(d->follows + i), & merged);
#line 2292
epsclosure(& merged, (struct dfa  const  *)d);
Liveness failed on function:
 void dfaanalyze(struct dfa *d , int searchflag ) 
{ int *nullable ;
  int *nfirstpos ;
  position *firstpos ;
  int *nlastpos ;
  position *lastpos ;
  int *nalloc ;
  position_set tmp ;
  position_set merged ;
  int wants_newline ;
  int *o_nullable ;
  int *o_nfirst ;
  int *o_nlast ;
  position *o_firstpos ;
  position *o_lastpos ;
  int i ;
  int j ;
  position *pos ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  int *tmp___24 ;
  int *tmp___25 ;
  int *tmp___26 ;
  int tmp___27 ;
  size_t new_nalloc ;
  void *tmp___28 ;
  size_t new_nalloc___0 ;
  void *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  int *tmp___33 ;
  int *tmp___34 ;
  int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  void *tmp___38 ;
  void *tmp___39 ;
  void *tmp___40 ;
  void *tmp___41 ;
  void *tmp___42 ;
  void *tmp___43 ;
  void *tmp___44 ;

  {
   2784: /* CIL Label */ 
#line 2122
  d->searchflag = searchflag;
   2785: /* CIL Label */ 
#line 2124
  if (sizeof(int ) == 1UL) {
#line 2124
    tmp___0 = xmalloc((unsigned long )d->depth);
#line 2124
    tmp___2 = tmp___0;
  } else {
#line 2124
    tmp___1 = xnmalloc((unsigned long )d->depth, sizeof(int ));
#line 2124
    tmp___2 = tmp___1;
  }
   2786: /* CIL Label */ 
#line 2124
  nullable = (int *)tmp___2;
   2787: /* CIL Label */ 
#line 2125
  o_nullable = nullable;
   2788: /* CIL Label */ 
#line 2126
  if (sizeof(int ) == 1UL) {
#line 2126
    tmp___3 = xmalloc((unsigned long )d->depth);
#line 2126
    tmp___5 = tmp___3;
  } else {
#line 2126
    tmp___4 = xnmalloc((unsigned long )d->depth, sizeof(int ));
#line 2126
    tmp___5 = tmp___4;
  }
   2789: /* CIL Label */ 
#line 2126
  nfirstpos = (int *)tmp___5;
   2790: /* CIL Label */ 
#line 2127
  o_nfirst = nfirstpos;
   2791: /* CIL Label */ 
#line 2128
  if (sizeof(position ) == 1UL) {
#line 2128
    tmp___6 = xmalloc((unsigned long )d->nleaves);
#line 2128
    tmp___8 = tmp___6;
  } else {
#line 2128
    tmp___7 = xnmalloc((unsigned long )d->nleaves, sizeof(position ));
#line 2128
    tmp___8 = tmp___7;
  }
   2792: /* CIL Label */ 
#line 2128
  firstpos = (position *)tmp___8;
   2793: /* CIL Label */ 
#line 2129
  o_firstpos = firstpos;
   2794: /* CIL Label */ 
#line 2129
  firstpos += d->nleaves;
   2795: /* CIL Label */ 
#line 2130
  if (sizeof(int ) == 1UL) {
#line 2130
    tmp___9 = xmalloc((unsigned long )d->depth);
#line 2130
    tmp___11 = tmp___9;
  } else {
#line 2130
    tmp___10 = xnmalloc((unsigned long )d->depth, sizeof(int ));
#line 2130
    tmp___11 = tmp___10;
  }
   2796: /* CIL Label */ 
#line 2130
  nlastpos = (int *)tmp___11;
   2797: /* CIL Label */ 
#line 2131
  o_nlast = nlastpos;
   2798: /* CIL Label */ 
#line 2132
  if (sizeof(position ) == 1UL) {
#line 2132
    tmp___12 = xmalloc((unsigned long )d->nleaves);
#line 2132
    tmp___14 = tmp___12;
  } else {
#line 2132
    tmp___13 = xnmalloc((unsigned long )d->nleaves, sizeof(position ));
#line 2132
    tmp___14 = tmp___13;
  }
   2799: /* CIL Label */ 
#line 2132
  lastpos = (position *)tmp___14;
   2800: /* CIL Label */ 
#line 2133
  o_lastpos = lastpos;
   2801: /* CIL Label */ 
#line 2133
  lastpos += d->nleaves;
   2802: /* CIL Label */ 
#line 2134
  if (sizeof(int ) == 1UL) {
#line 2134
    tmp___15 = xzalloc((unsigned long )d->tindex);
#line 2134
    tmp___17 = tmp___15;
  } else {
#line 2134
    tmp___16 = xcalloc((unsigned long )d->tindex, sizeof(int ));
#line 2134
    tmp___17 = tmp___16;
  }
   2803: /* CIL Label */ 
#line 2134
  nalloc = (int *)tmp___17;
   2804: /* CIL Label */ 
#line 2135
  if (sizeof(position ) == 1UL) {
#line 2135
    tmp___18 = xmalloc((unsigned long )(2 * d->nleaves));
#line 2135
    tmp___20 = tmp___18;
  } else {
#line 2135
    tmp___19 = xnmalloc((unsigned long )(2 * d->nleaves), sizeof(position ));
#line 2135
    tmp___20 = tmp___19;
  }
   2805: /* CIL Label */ 
#line 2135
  merged.elems = (position *)tmp___20;
   2806: /* CIL Label */ 
#line 2137
  if (sizeof(position_set ) == 1UL) {
#line 2137
    tmp___21 = xzalloc((unsigned long )d->tindex);
#line 2137
    tmp___23 = tmp___21;
  } else {
#line 2137
    tmp___22 = xcalloc((unsigned long )d->tindex, sizeof(position_set ));
#line 2137
    tmp___23 = tmp___22;
  }
   2807: /* CIL Label */ 
#line 2137
  d->follows = (position_set *)tmp___23;
   2808: /* CIL Label */ 
#line 2139
  i = 0;
   2809: /* CIL Label */ 
#line 2139
  while (i < d->tindex) {
#line 2143
    switch ((int )*(d->tokens + i)) {
    case 256: 
#line 2147
    tmp___24 = nullable;
#line 2147
    nullable ++;
#line 2147
    *tmp___24 = 1;
#line 2150
    tmp___25 = nfirstpos;
#line 2150
    nfirstpos ++;
#line 2150
    tmp___26 = nlastpos;
#line 2150
    nlastpos ++;
#line 2150
    tmp___27 = 0;
#line 2150
    *tmp___26 = tmp___27;
#line 2150
    *tmp___25 = tmp___27;
#line 2151
    break;
    case 265: 
    case 266: 
#line 2157
    tmp.nelem = *(nfirstpos + -1);
#line 2158
    tmp.elems = firstpos;
#line 2159
    pos = lastpos;
#line 2160
    j = 0;
#line 2160
    while (j < *(nlastpos + -1)) {
#line 2162
      merge((position_set const   *)(& tmp),
            (position_set const   *)(d->follows + (pos + j)->index), & merged);
#line 2163
      while (1) {
#line 2163
        if (*(nalloc + (pos + j)->index) <= merged.nelem - 1) {
#line 2163
          new_nalloc = (unsigned long )((merged.nelem - 1) + ! (d->follows + (pos + j)->index)->elems);
#line 2163
          tmp___28 = x2nrealloc((void *)(d->follows + (pos + j)->index)->elems,
                                & new_nalloc, sizeof(position ));
#line 2163
          (d->follows + (pos + j)->index)->elems = (position *)tmp___28;
#line 2163
          *(nalloc + (pos + j)->index) = (int )new_nalloc;
        } else {

        }
#line 2163
        break;
      }
#line 2165
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2160
      j ++;
    }
    case 264: 
#line 2170
    if ((int )*(d->tokens + i) != 266) {
#line 2171
      *(nullable + -1) = 1;
    } else {

    }
#line 2172
    break;
    case 268: 
#line 2177
    tmp.nelem = *(nfirstpos + -1);
#line 2178
    tmp.elems = firstpos;
#line 2179
    pos = lastpos + *(nlastpos + -1);
#line 2180
    j = 0;
#line 2180
    while (j < *(nlastpos + -2)) {
#line 2182
      merge((position_set const   *)(& tmp),
            (position_set const   *)(d->follows + (pos + j)->index), & merged);
#line 2183
      while (1) {
#line 2183
        if (*(nalloc + (pos + j)->index) <= merged.nelem - 1) {
#line 2183
          new_nalloc___0 = (unsigned long )((merged.nelem - 1) + ! (d->follows + (pos + j)->index)->elems);
#line 2183
          tmp___29 = x2nrealloc((void *)(d->follows + (pos + j)->index)->elems,
                                & new_nalloc___0, sizeof(position ));
#line 2183
          (d->follows + (pos + j)->index)->elems = (position *)tmp___29;
#line 2183
          *(nalloc + (pos + j)->index) = (int )new_nalloc___0;
        } else {

        }
#line 2183
        break;
      }
#line 2185
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2180
      j ++;
    }
#line 2190
    if (*(nullable + -2)) {
#line 2191
      *(nfirstpos + -2) += *(nfirstpos + -1);
    } else {
#line 2193
      firstpos += *(nfirstpos + -1);
    }
#line 2194
    nfirstpos --;
#line 2198
    if (*(nullable + -1)) {
#line 2199
      *(nlastpos + -2) += *(nlastpos + -1);
    } else {
#line 2202
      pos = lastpos + *(nlastpos + -2);
#line 2203
      j = *(nlastpos + -1) - 1;
#line 2203
      while (j >= 0) {
#line 2204
        *(pos + j) = *(lastpos + j);
#line 2203
        j --;
      }
#line 2205
      lastpos += *(nlastpos + -2);
#line 2206
      *(nlastpos + -2) = *(nlastpos + -1);
    }
#line 2208
    nlastpos --;
#line 2211
    if (*(nullable + -1)) {
#line 2211
      if (*(nullable + -2)) {
#line 2211
        tmp___30 = 1;
      } else {
#line 2211
        tmp___30 = 0;
      }
    } else {
#line 2211
      tmp___30 = 0;
    }
#line 2211
    *(nullable + -2) = tmp___30;
#line 2212
    nullable --;
#line 2213
    break;
    case 269: 
#line 2217
    *(nfirstpos + -2) += *(nfirstpos + -1);
#line 2218
    nfirstpos --;
#line 2221
    *(nlastpos + -2) += *(nlastpos + -1);
#line 2222
    nlastpos --;
#line 2225
    if (*(nullable + -1)) {
#line 2225
      tmp___31 = 1;
    } else {
#line 2225
      if (*(nullable + -2)) {
#line 2225
        tmp___31 = 1;
      } else {
#line 2225
        tmp___31 = 0;
      }
    }
#line 2225
    *(nullable + -2) = tmp___31;
#line 2226
    nullable --;
#line 2227
    break;
    default: 
#line 2235
    tmp___32 = nullable;
#line 2235
    nullable ++;
#line 2235
    *tmp___32 = (int )*(d->tokens + i) == 257;
#line 2238
    tmp___33 = nfirstpos;
#line 2238
    nfirstpos ++;
#line 2238
    tmp___34 = nlastpos;
#line 2238
    nlastpos ++;
#line 2238
    tmp___35 = 1;
#line 2238
    *tmp___34 = tmp___35;
#line 2238
    *tmp___33 = tmp___35;
#line 2239
    firstpos --;
#line 2239
    lastpos --;
#line 2240
    tmp___36 = (unsigned int )i;
#line 2240
    lastpos->index = tmp___36;
#line 2240
    firstpos->index = tmp___36;
#line 2241
    tmp___37 = 255U;
#line 2241
    lastpos->constraint = tmp___37;
#line 2241
    firstpos->constraint = tmp___37;
#line 2244
    *(nalloc + i) = 1;
#line 2245
    if (sizeof(position ) == 1UL) {
#line 2245
      tmp___38 = xmalloc((unsigned long )*(nalloc + i));
#line 2245
      tmp___40 = tmp___38;
    } else {
#line 2245
      tmp___39 = xnmalloc((unsigned long )*(nalloc + i), sizeof(position ));
#line 2245
      tmp___40 = tmp___39;
    }
#line 2245
    (d->follows + i)->elems = (position *)tmp___40;
#line 2246
    break;
    }
#line 2139
    i ++;
  }
   2810: /* CIL Label */ 
#line 2272
  i = 0;
   2811: /* CIL Label */ 
#line 2272
  while (i < d->tindex) {
#line 2273
    if ((int )*(d->tokens + i) < 1 << 8) {
      goto _L;
    } else {
#line 2273
      if ((int )*(d->tokens + i) == 257) {
        goto _L;
      } else {
#line 2273
        if ((int )*(d->tokens + i) == 272) {
          goto _L;
        } else {
#line 2273
          if ((int )*(d->tokens + i) == 273) {
            goto _L;
          } else {
#line 2273
            if ((int )*(d->tokens + i) >= 275) {
              _L: 
#line 2291
              copy((position_set const   *)(d->follows + i), & merged);
#line 2292
              epsclosure(& merged, (struct dfa  const  *)d);
#line 2293
              if ((d->follows + i)->nelem < merged.nelem) {
#line 2294
                tmp___41 = xnrealloc((void *)(d->follows + i)->elems,
                                     (unsigned long )merged.nelem,
                                     sizeof(position ));
#line 2294
                (d->follows + i)->elems = (position *)tmp___41;
              } else {

              }
#line 2295
              copy((position_set const   *)(& merged), d->follows + i);
            } else {

            }
          }
        }
      }
    }
#line 2272
    i ++;
  }
   2812: /* CIL Label */ 
#line 2300
  merged.nelem = 0;
   2813: /* CIL Label */ 
#line 2301
  i = 0;
   2814: /* CIL Label */ 
#line 2301
  while (i < *(nfirstpos + -1)) {
#line 2302
    insert(*(firstpos + i), & merged);
#line 2301
    i ++;
  }
   2815: /* CIL Label */ 
#line 2303
  epsclosure(& merged, (struct dfa  const  *)d);
   2816: /* CIL Label */ 
#line 2306
  wants_newline = 0;
   2817: /* CIL Label */ 
#line 2307
  i = 0;
   2818: /* CIL Label */ 
#line 2307
  while (i < merged.nelem) {
#line 2308
    if (((merged.elems + i)->constraint & 192U) >> 2 != ((merged.elems + i)->constraint & 48U)) {
#line 2309
      wants_newline = 1;
    } else {

    }
#line 2307
    i ++;
  }
   2819: /* CIL Label */ 
#line 2312
  d->salloc = 1;
   2820: /* CIL Label */ 
#line 2313
  d->sindex = 0;
   2821: /* CIL Label */ 
#line 2314
  if (sizeof(dfa_state ) == 1UL) {
#line 2314
    tmp___42 = xmalloc((unsigned long )d->salloc);
#line 2314
    tmp___44 = tmp___42;
  } else {
#line 2314
    tmp___43 = xnmalloc((unsigned long )d->salloc, sizeof(dfa_state ));
#line 2314
    tmp___44 = tmp___43;
  }
   2822: /* CIL Label */ 
#line 2314
  d->states = (dfa_state *)tmp___44;
   2823: /* CIL Label */ 
#line 2315
  state_index(d, (position_set const   *)(& merged), wants_newline, 0);
   2824: /* CIL Label */ 
#line 2317
  free((void *)o_nullable);
   2825: /* CIL Label */ 
#line 2318
  free((void *)o_nfirst);
   2826: /* CIL Label */ 
#line 2319
  free((void *)o_firstpos);
   2827: /* CIL Label */ 
#line 2320
  free((void *)o_nlast);
   2828: /* CIL Label */ 
#line 2321
  free((void *)o_lastpos);
   2829: /* CIL Label */ 
#line 2322
  free((void *)nalloc);
   2830: /* CIL Label */ 
#line 2323
  free((void *)merged.elems);
   2831: /* CIL Label */ 
#line 2324
  return;
}
}

cilRep: liveness failure for dfaanalyze: Errormsg.Error
Bug: BF(Liveness): stmtStartData is not initialized for -1: _L___1: 
#line 2599
j = 0;
Liveness failed on function:
 void dfastate(int s , struct dfa *d , int *trans ) 
{ position_set *grps ;
  charclass *labels ;
  int ngrps ;
  position pos ;
  charclass matches ;
  int matchesf ;
  charclass intersect ;
  int intersectf ;
  charclass leftovers ;
  int leftoversf ;
  position_set follows ;
  position_set tmp ;
  int state ;
  int wants_newline ;
  int state_newline ;
  int wants_letter ;
  int state_letter ;
  int next_isnt_1st_byte ;
  int i ;
  int j ;
  int k ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned short const   **tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int match ;
  int label ;
  int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  unsigned short const   **tmp___28 ;
  int tmp___29 ;
  int c ;
  unsigned short const   **tmp___30 ;

  {
   3146: /* CIL Label */ 
#line 2361
  ngrps = 0;
   3147: /* CIL Label */ 
#line 2380
  next_isnt_1st_byte = 0;
   3148: /* CIL Label */ 
#line 2384
  tmp___0 = xnmalloc((unsigned long )(1 << 8), sizeof(*grps));
   3149: /* CIL Label */ 
#line 2384
  grps = (position_set *)tmp___0;
   3150: /* CIL Label */ 
#line 2385
  tmp___1 = xnmalloc((unsigned long )(1 << 8), sizeof(*labels));
   3151: /* CIL Label */ 
#line 2385
  labels = (charclass *)tmp___1;
   3152: /* CIL Label */ 
#line 2388
  if (! initialized) {
#line 2390
    initialized = 1;
#line 2391
    i = 0;
#line 2391
    while (i < 1 << 8) {
#line 2392
      tmp___2 = __ctype_b_loc();
#line 2392
      if ((int const   )*(*tmp___2 + i) & 8) {
#line 2393
        setbit((unsigned int )i, letters);
      } else {
#line 2392
        if (i == 95) {
#line 2393
          setbit((unsigned int )i, letters);
        } else {

        }
      }
#line 2391
      i ++;
    }
#line 2394
    setbit((unsigned int )eolbyte, newline);
  } else {

  }
   3153: /* CIL Label */ 
#line 2397
  zeroset(matches);
   3154: /* CIL Label */ 
#line 2399
  i = 0;
   3155: /* CIL Label */ 
#line 2399
  while (i < (d->states + s)->elems.nelem) {
#line 2401
    pos = *((d->states + s)->elems.elems + i);
#line 2402
    if ((int )*(d->tokens + pos.index) >= 0) {
#line 2402
      if ((int )*(d->tokens + pos.index) < 1 << 8) {
#line 2403
        setbit((unsigned int )*(d->tokens + pos.index), matches);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
#line 2404
      if ((int )*(d->tokens + pos.index) >= 275) {
#line 2405
        copyset(*(d->charclasses + ((int )*(d->tokens + pos.index) - 275)),
                matches);
      } else {
#line 2407
        if ((int )*(d->tokens + pos.index) == 272) {
          goto _L;
        } else {
#line 2407
          if ((int )*(d->tokens + pos.index) == 273) {
            _L: 
#line 2414
            if ((d->states + s)->mbps.nelem == 0) {
#line 2416
              if (sizeof(position ) == 1UL) {
#line 2416
                tmp___3 = xmalloc((unsigned long )(d->states + s)->elems.nelem);
#line 2416
                tmp___5 = tmp___3;
              } else {
#line 2416
                tmp___4 = xnmalloc((unsigned long )(d->states + s)->elems.nelem,
                                   sizeof(position ));
#line 2416
                tmp___5 = tmp___4;
              }
#line 2416
              (d->states + s)->mbps.elems = (position *)tmp___5;
            } else {

            }
#line 2419
            insert(pos, & (d->states + s)->mbps);
            goto __Cont;
          } else {
            goto __Cont;
          }
        }
      }
    }
#line 2428
    if (pos.constraint != 255U) {
#line 2430
      if ((d->states + s)->newline) {
#line 2430
        tmp___6 = 2;
      } else {
#line 2430
        tmp___6 = 0;
      }
#line 2430
      if (! (pos.constraint & (unsigned int )(1 << ((tmp___6 + 1) + 4)))) {
#line 2432
        clrbit((unsigned int )eolbyte, matches);
      } else {

      }
#line 2433
      if ((d->states + s)->newline) {
#line 2433
        tmp___7 = 2;
      } else {
#line 2433
        tmp___7 = 0;
      }
#line 2433
      if (! (pos.constraint & (unsigned int )(1 << (tmp___7 + 4)))) {
#line 2435
        j = 0;
#line 2435
        while ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2436
          matches[j] &= newline[j];
#line 2435
          j ++;
        }
      } else {

      }
#line 2437
      if ((d->states + s)->letter) {
#line 2437
        tmp___8 = 2;
      } else {
#line 2437
        tmp___8 = 0;
      }
#line 2437
      if (! (pos.constraint & (unsigned int )(1 << (tmp___8 + 1)))) {
#line 2439
        j = 0;
#line 2439
        while ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2440
          matches[j] &= ~ letters[j];
#line 2439
          j ++;
        }
      } else {

      }
#line 2441
      if ((d->states + s)->letter) {
#line 2441
        tmp___9 = 2;
      } else {
#line 2441
        tmp___9 = 0;
      }
#line 2441
      if (! (pos.constraint & (unsigned int )(1 << tmp___9))) {
#line 2443
        j = 0;
#line 2443
        while ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2444
          matches[j] &= letters[j];
#line 2443
          j ++;
        }
      } else {

      }
#line 2447
      j = 0;
#line 2447
      while (1) {
#line 2447
        if ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2447
          if (! (! matches[j])) {
#line 2447
            break;
          } else {

          }
        } else {
#line 2447
          break;
        }
        goto __Cont___0;
        __Cont___0: 
#line 2447
        j ++;
      }
#line 2449
      if ((unsigned long )j == (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
        goto __Cont;
      } else {

      }
    } else {

    }
#line 2453
    j = 0;
#line 2453
    while (j < ngrps) {
#line 2458
      if ((int )*(d->tokens + pos.index) >= 0) {
#line 2458
        if ((int )*(d->tokens + pos.index) < 1 << 8) {
#line 2458
          tmp___10 = tstbit((unsigned int )*(d->tokens + pos.index),
                            *(labels + j));
#line 2458
          if (! tmp___10) {
            goto __Cont___1;
          } else {

          }
        } else {

        }
      } else {

      }
#line 2464
      intersectf = 0;
#line 2465
      k = 0;
#line 2465
      while ((unsigned long )k < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2466
        tmp___11 = matches[k] & (*(labels + j))[k];
#line 2466
        intersect[k] = tmp___11;
#line 2466
        if (tmp___11) {
#line 2466
          intersectf = 1;
        } else {

        }
#line 2465
        k ++;
      }
#line 2467
      if (! intersectf) {
        goto __Cont___1;
      } else {

      }
#line 2471
      matchesf = 0;
#line 2471
      leftoversf = matchesf;
#line 2472
      k = 0;
#line 2472
      while ((unsigned long )k < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2475
        match = matches[k];
#line 2475
        label = (*(labels + j))[k];
#line 2477
        tmp___12 = ~ match & label;
#line 2477
        leftovers[k] = tmp___12;
#line 2477
        if (tmp___12) {
#line 2477
          leftoversf = 1;
        } else {

        }
#line 2478
        tmp___13 = match & ~ label;
#line 2478
        matches[k] = tmp___13;
#line 2478
        if (tmp___13) {
#line 2478
          matchesf = 1;
        } else {

        }
#line 2472
        k ++;
      }
#line 2482
      if (leftoversf) {
#line 2484
        copyset(leftovers, *(labels + ngrps));
#line 2485
        copyset(intersect, *(labels + j));
#line 2486
        if (sizeof(position ) == 1UL) {
#line 2486
          tmp___14 = xmalloc((unsigned long )d->nleaves);
#line 2486
          tmp___16 = tmp___14;
        } else {
#line 2486
          tmp___15 = xnmalloc((unsigned long )d->nleaves, sizeof(position ));
#line 2486
          tmp___16 = tmp___15;
        }
#line 2486
        (grps + ngrps)->elems = (position *)tmp___16;
#line 2487
        copy((position_set const   *)(grps + j), grps + ngrps);
#line 2488
        ngrps ++;
      } else {

      }
#line 2493
      tmp___17 = (grps + j)->nelem;
#line 2493
      ((grps + j)->nelem) ++;
#line 2493
      *((grps + j)->elems + tmp___17) = pos;
#line 2497
      if (! matchesf) {
#line 2498
        break;
      } else {

      }
      __Cont___1: 
#line 2453
      j ++;
    }
#line 2503
    if (j == ngrps) {
#line 2505
      copyset(matches, *(labels + ngrps));
#line 2506
      zeroset(matches);
#line 2507
      if (sizeof(position ) == 1UL) {
#line 2507
        tmp___18 = xmalloc((unsigned long )d->nleaves);
#line 2507
        tmp___20 = tmp___18;
      } else {
#line 2507
        tmp___19 = xnmalloc((unsigned long )d->nleaves, sizeof(position ));
#line 2507
        tmp___20 = tmp___19;
      }
#line 2507
      (grps + ngrps)->elems = (position *)tmp___20;
#line 2508
      (grps + ngrps)->nelem = 1;
#line 2509
      *((grps + ngrps)->elems + 0) = pos;
#line 2510
      ngrps ++;
    } else {

    }
    __Cont: 
#line 2399
    i ++;
  }
   3156: /* CIL Label */ 
#line 2514
  if (sizeof(position ) == 1UL) {
#line 2514
    tmp___21 = xmalloc((unsigned long )d->nleaves);
#line 2514
    tmp___23 = tmp___21;
  } else {
#line 2514
    tmp___22 = xnmalloc((unsigned long )d->nleaves, sizeof(position ));
#line 2514
    tmp___23 = tmp___22;
  }
   3157: /* CIL Label */ 
#line 2514
  follows.elems = (position *)tmp___23;
   3158: /* CIL Label */ 
#line 2515
  if (sizeof(position ) == 1UL) {
#line 2515
    tmp___24 = xmalloc((unsigned long )d->nleaves);
#line 2515
    tmp___26 = tmp___24;
  } else {
#line 2515
    tmp___25 = xnmalloc((unsigned long )d->nleaves, sizeof(position ));
#line 2515
    tmp___26 = tmp___25;
  }
   3159: /* CIL Label */ 
#line 2515
  tmp.elems = (position *)tmp___26;
   3160: /* CIL Label */ 
#line 2520
  if (d->searchflag) {
#line 2522
    wants_newline = 0;
#line 2523
    wants_letter = 0;
#line 2524
    i = 0;
#line 2524
    while (i < (d->states + 0)->elems.nelem) {
#line 2526
      if ((((d->states + 0)->elems.elems + i)->constraint & 192U) >> 2 != (((d->states + 0)->elems.elems + i)->constraint & 48U)) {
#line 2527
        wants_newline = 1;
      } else {

      }
#line 2528
      if ((((d->states + 0)->elems.elems + i)->constraint & 12U) >> 2 != (((d->states + 0)->elems.elems + i)->constraint & 3U)) {
#line 2529
        wants_letter = 1;
      } else {

      }
#line 2524
      i ++;
    }
#line 2531
    copy((position_set const   *)(& (d->states + 0)->elems), & follows);
#line 2532
    state = state_index(d, (position_set const   *)(& follows), 0, 0);
#line 2533
    if (wants_newline) {
#line 2534
      state_newline = state_index(d, (position_set const   *)(& follows), 1, 0);
    } else {
#line 2536
      state_newline = state;
    }
#line 2537
    if (wants_letter) {
#line 2538
      state_letter = state_index(d, (position_set const   *)(& follows), 0, 1);
    } else {
#line 2540
      state_letter = state;
    }
#line 2541
    i = 0;
#line 2541
    while (i < 1 << 8) {
#line 2542
      tmp___28 = __ctype_b_loc();
#line 2542
      if ((int const   )*(*tmp___28 + i) & 8) {
#line 2542
        *(trans + i) = state_letter;
      } else {
#line 2542
        if (i == 95) {
#line 2542
          *(trans + i) = state_letter;
        } else {
#line 2542
          *(trans + i) = state;
        }
      }
#line 2541
      i ++;
    }
#line 2543
    *(trans + (int )eolbyte) = state_newline;
  } else {
#line 2546
    i = 0;
#line 2546
    while (i < 1 << 8) {
#line 2547
      *(trans + i) = -1;
#line 2546
      i ++;
    }
  }
   3161: /* CIL Label */ 
#line 2549
  i = 0;
   3162: /* CIL Label */ 
#line 2549
  while (i < ngrps) {
#line 2551
    follows.nelem = 0;
#line 2555
    j = 0;
#line 2555
    while (j < (grps + i)->nelem) {
#line 2556
      k = 0;
#line 2556
      while (k < (d->follows + ((grps + i)->elems + j)->index)->nelem) {
#line 2557
        insert(*((d->follows + ((grps + i)->elems + j)->index)->elems + k),
               & follows);
#line 2556
        k ++;
      }
#line 2555
      j ++;
    }
#line 2560
    if (d->mb_cur_max > 1U) {
#line 2580
      next_isnt_1st_byte = 0;
#line 2581
      j = 0;
#line 2581
      while (j < follows.nelem) {
#line 2583
        if (! (*(d->multibyte_prop + (follows.elems + j)->index) & 1)) {
#line 2585
          next_isnt_1st_byte = 1;
#line 2586
          break;
        } else {

        }
#line 2581
        j ++;
      }
    } else {

    }
#line 2595
    if (d->searchflag) {
#line 2595
      if (d->mb_cur_max == 1U) {
        goto _L___1;
      } else {
#line 2595
        if (! next_isnt_1st_byte) {
          _L___1: 
#line 2599
          j = 0;
#line 2599
          while (j < (d->states + 0)->elems.nelem) {
#line 2600
            insert(*((d->states + 0)->elems.elems + j), & follows);
#line 2599
            j ++;
          }
        } else {

        }
      }
    } else {

    }
#line 2603
    wants_newline = 0;
#line 2604
    tmp___29 = tstbit((unsigned int )eolbyte, *(labels + i));
#line 2604
    if (tmp___29) {
#line 2605
      j = 0;
#line 2605
      while (j < follows.nelem) {
#line 2606
        if (((follows.elems + j)->constraint & 192U) >> 2 != ((follows.elems + j)->constraint & 48U)) {
#line 2607
          wants_newline = 1;
        } else {

        }
#line 2605
        j ++;
      }
    } else {

    }
#line 2609
    wants_letter = 0;
#line 2610
    j = 0;
#line 2610
    while ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2611
      if ((*(labels + i))[j] & letters[j]) {
#line 2612
        break;
      } else {

      }
#line 2610
      j ++;
    }
#line 2613
    if ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2614
      j = 0;
#line 2614
      while (j < follows.nelem) {
#line 2615
        if (((follows.elems + j)->constraint & 12U) >> 2 != ((follows.elems + j)->constraint & 3U)) {
#line 2616
          wants_letter = 1;
        } else {

        }
#line 2614
        j ++;
      }
    } else {

    }
#line 2619
    state = state_index(d, (position_set const   *)(& follows), 0, 0);
#line 2620
    if (wants_newline) {
#line 2621
      state_newline = state_index(d, (position_set const   *)(& follows), 1, 0);
    } else {
#line 2623
      state_newline = state;
    }
#line 2624
    if (wants_letter) {
#line 2625
      state_letter = state_index(d, (position_set const   *)(& follows), 0, 1);
    } else {
#line 2627
      state_letter = state;
    }
#line 2630
    j = 0;
#line 2630
    while ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2631
      k = 0;
#line 2631
      while ((unsigned long )k < 8UL * sizeof(int )) {
#line 2632
        if ((*(labels + i))[j] & (1 << k)) {
#line 2634
          c = (int )((unsigned long )j * (8UL * sizeof(int )) + (unsigned long )k);
#line 2636
          if (c == (int )eolbyte) {
#line 2637
            *(trans + c) = state_newline;
          } else {
#line 2638
            tmp___30 = __ctype_b_loc();
#line 2638
            if ((int const   )*(*tmp___30 + c) & 8) {
#line 2639
              *(trans + c) = state_letter;
            } else {
#line 2638
              if (c == 95) {
#line 2639
                *(trans + c) = state_letter;
              } else {
#line 2640
                if (c < 1 << 8) {
#line 2641
                  *(trans + c) = state;
                } else {

                }
              }
            }
          }
        } else {

        }
#line 2631
        k ++;
      }
#line 2630
      j ++;
    }
#line 2549
    i ++;
  }
   3163: /* CIL Label */ 
#line 2645
  i = 0;
   3164: /* CIL Label */ 
#line 2645
  while (i < ngrps) {
#line 2646
    free((void *)(grps + i)->elems);
#line 2645
    i ++;
  }
   3165: /* CIL Label */ 
#line 2647
  free((void *)follows.elems);
   3166: /* CIL Label */ 
#line 2648
  free((void *)tmp.elems);
   3167: /* CIL Label */ 
#line 2649
  free((void *)grps);
   3168: /* CIL Label */ 
#line 2650
  free((void *)labels);
   3169: /* CIL Label */ 
#line 2651
  return;
}
}

cilRep: liveness failure for dfastate: Errormsg.Error
Bug: BF(Liveness): stmtStartData is not initialized for -1: _L: 
#line 3128
rs = transit_state_singlebyte(d, s, *pp, & s1);
Liveness failed on function:
 static int transit_state(struct dfa *d , int s , unsigned char const   **pp ) 
{ int s1 ;
  int mbclen ;
  int maxlen ;
  int i ;
  int j ;
  int *match_lens ;
  int nelem ;
  position_set follows ;
  unsigned char const   *p1 ;
  wchar_t wc ;
  status_transit_state rs ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
   3595: /* CIL Label */ 
#line 3099
  maxlen = 0;
   3596: /* CIL Label */ 
#line 3101
  match_lens = (int *)((void *)0);
   3597: /* CIL Label */ 
#line 3102
  nelem = (d->states + s)->mbps.nelem;
   3598: /* CIL Label */ 
#line 3104
  p1 = *pp;
   3599: /* CIL Label */ 
#line 3107
  if (nelem > 0) {
#line 3112
    match_lens = check_matching_with_multibyte_ops(d, s, *pp - buf_begin);
#line 3114
    i = 0;
#line 3114
    while (i < nelem) {
#line 3118
      if (*(match_lens + i) > maxlen) {
#line 3119
        maxlen = *(match_lens + i);
      } else {

      }
#line 3114
      i ++;
    }
  } else {

  }
   3600: /* CIL Label */ 
#line 3123
  if (nelem == 0) {
    goto _L;
  } else {
#line 3123
    if (maxlen == 0) {
      _L: 
#line 3128
      rs = transit_state_singlebyte(d, s, *pp, & s1);
#line 3131
      if ((unsigned int )rs == 1U) {
#line 3132
        (*pp) ++;
      } else {

      }
#line 3134
      free((void *)match_lens);
#line 3135
      return (s1);
    } else {

    }
  }
   3601: /* CIL Label */ 
#line 3139
  follows.nelem = 0;
   3602: /* CIL Label */ 
#line 3140
  if (sizeof(position ) == 1UL) {
#line 3140
    tmp = xmalloc((unsigned long )d->nleaves);
#line 3140
    tmp___1 = tmp;
  } else {
#line 3140
    tmp___0 = xnmalloc((unsigned long )d->nleaves, sizeof(position ));
#line 3140
    tmp___1 = tmp___0;
  }
   3603: /* CIL Label */ 
#line 3140
  follows.elems = (position *)tmp___1;
   3604: /* CIL Label */ 
#line 3146
  transit_state_consume_1char(d, s, pp, match_lens, & mbclen, & follows);
   3605: /* CIL Label */ 
#line 3148
  wc = *(inputwcs + ((*pp - mbclen) - buf_begin));
   3606: /* CIL Label */ 
#line 3149
  tmp___2 = iswalnum((unsigned int )wc);
   3607: /* CIL Label */ 
#line 3149
  s1 = state_index(d, (position_set const   *)(& follows), wc == 10, tmp___2);
   3608: /* CIL Label */ 
#line 3150
  realloc_trans_if_necessary(d, s1);
   3609: /* CIL Label */ 
#line 3152
  while (*pp - p1 < maxlen) {
#line 3154
    follows.nelem = 0;
#line 3155
    transit_state_consume_1char(d, s1, pp, (int *)((void *)0), & mbclen,
                                & follows);
#line 3157
    i = 0;
#line 3157
    while (i < nelem) {
#line 3159
      if (*(match_lens + i) == *pp - p1) {
#line 3160
        j = 0;
#line 3160
        while (j < (d->follows + ((d->states + s1)->mbps.elems + i)->index)->nelem) {
#line 3162
          insert(*((d->follows + ((d->states + s1)->mbps.elems + i)->index)->elems + j),
                 & follows);
#line 3160
          j ++;
        }
      } else {

      }
#line 3157
      i ++;
    }
#line 3166
    wc = *(inputwcs + ((*pp - mbclen) - buf_begin));
#line 3167
    tmp___3 = iswalnum((unsigned int )wc);
#line 3167
    s1 = state_index(d, (position_set const   *)(& follows), wc == 10, tmp___3);
#line 3168
    realloc_trans_if_necessary(d, s1);
  }
   3610: /* CIL Label */ 
#line 3170
  free((void *)match_lens);
   3611: /* CIL Label */ 
#line 3171
  free((void *)follows.elems);
   3612: /* CIL Label */ 
#line 3172
  return (s1);
}
}

cilRep: liveness failure for transit_state: Errormsg.Error
Bug: BF(Liveness): stmtStartData is not initialized for -1: _L: 
#line 3197
remain_bytes = 0UL;
#line 3198
*(inputwcs + i) = (int )*(begin + i);
#line 3199
*(mblen_buf + i) = (unsigned char)0;
Liveness failed on function:
 static void prepare_wc_buf(char const   *begin , char const   *end ) 
{ unsigned char eol ;
  size_t remain_bytes ;
  size_t i ;

  {
   3638: /* CIL Label */ 
#line 3180
  eol = eolbyte;
   3639: /* CIL Label */ 
#line 3183
  buf_begin = (unsigned char const   *)((unsigned char *)begin);
   3640: /* CIL Label */ 
#line 3185
  remain_bytes = 0UL;
   3641: /* CIL Label */ 
#line 3186
  i = 0UL;
   3642: /* CIL Label */ 
#line 3186
  while (i < (unsigned long )((end - begin) + 1)) {
#line 3188
    if (remain_bytes == 0UL) {
#line 3190
      remain_bytes = mbrtowc((wchar_t */* __restrict  */)(inputwcs + i),
                             (char const   */* __restrict  */)(begin + i),
                             ((unsigned long )(end - begin) - i) + 1UL,
                             (mbstate_t */* __restrict  */)(& mbs));
#line 3192
      if (remain_bytes < 1UL) {
        goto _L;
      } else {
#line 3192
        if (remain_bytes == 4294967295UL) {
          goto _L;
        } else {
#line 3192
          if (remain_bytes == 4294967294UL) {
            goto _L;
          } else {
#line 3192
            if (remain_bytes == 1UL) {
#line 3192
              if (*(inputwcs + i) == (int )*(begin + i)) {
                _L: 
#line 3197
                remain_bytes = 0UL;
#line 3198
                *(inputwcs + i) = (int )*(begin + i);
#line 3199
                *(mblen_buf + i) = (unsigned char)0;
#line 3200
                if ((int const   )*(begin + i) == (int const   )eol) {
#line 3201
                  break;
                } else {

                }
              } else {
#line 3205
                *(mblen_buf + i) = (unsigned char )remain_bytes;
#line 3206
                remain_bytes --;
              }
            } else {
#line 3205
              *(mblen_buf + i) = (unsigned char )remain_bytes;
#line 3206
              remain_bytes --;
            }
          }
        }
      }
    } else {
#line 3211
      *(mblen_buf + i) = (unsigned char )remain_bytes;
#line 3212
      *(inputwcs + i) = 0;
#line 3213
      remain_bytes --;
    }
#line 3186
    i ++;
  }
   3643: /* CIL Label */ 
#line 3217
  buf_end = (unsigned char const   *)((unsigned char *)(begin + i));
   3644: /* CIL Label */ 
#line 3218
  *(mblen_buf + i) = (unsigned char)0;
   3645: /* CIL Label */ 
#line 3219
  *(inputwcs + i) = 0;
   3646: /* CIL Label */ 
#line 3220
  return;
}
}

cilRep: liveness failure for prepare_wc_buf: Errormsg.Error
Bug: BF(Liveness): stmtStartData is not initialized for -1: __Cont___0: 
#line 3735
lcp ++;
Liveness failed on function:
 static char **comsubs(char *left , char const   *right ) 
{ char **cpp ;
  char *lcp ;
  char *rcp ;
  size_t i ;
  size_t len ;
  void *tmp ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
   4058: /* CIL Label */ 
#line 3729
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 3730
    return ((char **)((void *)0));
  } else {
#line 3729
    if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 3730
      return ((char **)((void *)0));
    } else {

    }
  }
   4059: /* CIL Label */ 
#line 3731
  tmp = malloc(sizeof(*cpp));
   4060: /* CIL Label */ 
#line 3731
  cpp = (char **)tmp;
   4061: /* CIL Label */ 
#line 3732
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3733
    return ((char **)((void *)0));
  } else {

  }
   4062: /* CIL Label */ 
#line 3734
  *(cpp + 0) = (char *)((void *)0);
   4063: /* CIL Label */ 
#line 3735
  lcp = left;
   4064: /* CIL Label */ 
#line 3735
  while ((int )*lcp != 0) {
#line 3737
    len = 0UL;
#line 3738
    tmp___1 = __builtin_strchr((char *)right, (int )*lcp);
#line 3738
    rcp = tmp___1;
#line 3739
    while ((unsigned long )rcp != (unsigned long )((void *)0)) {
#line 3741
      i = 1UL;
#line 3741
      while (1) {
#line 3741
        if ((int )*(lcp + i) != 0) {
#line 3741
          if (! ((int )*(lcp + i) == (int )*(rcp + i))) {
#line 3741
            break;
          } else {

          }
        } else {
#line 3741
          break;
        }
        goto __Cont;
        __Cont: 
#line 3741
        i ++;
      }
#line 3743
      if (i > len) {
#line 3744
        len = i;
      } else {

      }
#line 3745
      tmp___3 = __builtin_strchr(rcp + 1, (int )*lcp);
#line 3745
      rcp = tmp___3;
    }
#line 3747
    if (len == 0UL) {
      goto __Cont___0;
    } else {

    }
#line 3749
    cpp = enlist(cpp, lcp, len);
#line 3749
    if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3750
      break;
    } else {

    }
    __Cont___0: 
#line 3735
    lcp ++;
  }
   4065: /* CIL Label */ 
#line 3752
  return (cpp);
}
}

cilRep: liveness failure for comsubs: Errormsg.Error
Bug: BF(Liveness): stmtStartData is not initialized for -1: done: 
#line 4037
tmp___37 = strlen((char const   *)result);
Liveness failed on function:
 static void dfamust(struct dfa *d ) 
{ must *musts ;
  must *mp ;
  char *result ;
  int ri ;
  int i ;
  int exact ;
  token t ;
  struct dfamust *dm ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char tmp___4 ;
  char tmp___5 ;
  char **new ;
  must *lmp ;
  must *rmp ;
  int j ;
  int ln ;
  int rn ;
  int n ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  must *lmp___0 ;
  must *rmp___0 ;
  char *tp ;
  size_t tmp___24 ;
  char tmp___25 ;
  char tmp___26 ;
  char tmp___27 ;
  char tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  size_t tmp___32 ;
  void *tmp___33 ;
  size_t tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  size_t tmp___37 ;

  {
   4372: /* CIL Label */ 
#line 3835
  result = empty_string;
   4373: /* CIL Label */ 
#line 3836
  exact = 0;
   4374: /* CIL Label */ 
#line 3837
  tmp = xnmalloc((unsigned long )(d->tindex + 1), sizeof(*musts));
   4375: /* CIL Label */ 
#line 3837
  musts = (must *)tmp;
   4376: /* CIL Label */ 
#line 3838
  mp = musts;
   4377: /* CIL Label */ 
#line 3839
  i = 0;
   4378: /* CIL Label */ 
#line 3839
  while (i <= d->tindex) {
#line 3840
    *(mp + i) = must0;
#line 3839
    i ++;
  }
   4379: /* CIL Label */ 
#line 3841
  i = 0;
   4380: /* CIL Label */ 
#line 3841
  while (i <= d->tindex) {
#line 3843
    tmp___0 = malloc(sizeof(*((mp + i)->in)));
#line 3843
    (mp + i)->in = (char **)tmp___0;
#line 3844
    tmp___1 = malloc(2UL);
#line 3844
    (mp + i)->left = (char *)tmp___1;
#line 3845
    tmp___2 = malloc(2UL);
#line 3845
    (mp + i)->right = (char *)tmp___2;
#line 3846
    tmp___3 = malloc(2UL);
#line 3846
    (mp + i)->is = (char *)tmp___3;
#line 3847
    if ((unsigned long )(mp + i)->in == (unsigned long )((void *)0)) {
      goto done;
    } else {
#line 3847
      if ((unsigned long )(mp + i)->left == (unsigned long )((void *)0)) {
        goto done;
      } else {
#line 3847
        if ((unsigned long )(mp + i)->right == (unsigned long )((void *)0)) {
          goto done;
        } else {
#line 3847
          if ((unsigned long )(mp + i)->is == (unsigned long )((void *)0)) {
            goto done;
          } else {

          }
        }
      }
    }
#line 3850
    tmp___5 = (char )'\000';
#line 3850
    *((mp + i)->is + 0) = tmp___5;
#line 3850
    tmp___4 = tmp___5;
#line 3850
    *((mp + i)->right + 0) = tmp___4;
#line 3850
    *((mp + i)->left + 0) = tmp___4;
#line 3851
    *((mp + i)->in + 0) = (char *)((void *)0);
#line 3841
    i ++;
  }
   4381: /* CIL Label */ 
#line 3862
  ri = 0;
   4382: /* CIL Label */ 
#line 3862
  while (ri < d->tindex) {
#line 3864
    t = *(d->tokens + ri);
#line 3864
    switch ((int )t) {
    case 270: 
    case 271: 
#line 3868
    __assert_fail("!\"neither LPAREN nor RPAREN may appear here\"", "dfa.c",
                  3868U, "dfamust");
    case 256: 
    case 258: 
    case 259: 
    case 260: 
    case 261: 
    case 262: 
    case 263: 
    case 257: 
#line 3877
    resetmust(mp);
#line 3878
    break;
    case 265: 
    case 264: 
#line 3881
    if (! ((unsigned long )musts < (unsigned long )mp)) {
#line 3881
      __assert_fail("musts < mp", "dfa.c", 3881U, "dfamust");
    } else {

    }
#line 3882
    mp --;
#line 3883
    resetmust(mp);
#line 3884
    break;
    case 269: 
#line 3886
    if (! ((unsigned long )(musts + 2) <= (unsigned long )mp)) {
#line 3886
      __assert_fail("&musts[2] <= mp", "dfa.c", 3886U, "dfamust");
    } else {

    }
#line 3893
    mp --;
#line 3893
    rmp = mp;
#line 3894
    mp --;
#line 3894
    lmp = mp;
#line 3896
    if (0) {
#line 3896
      __s1_len = __builtin_strlen((char const   *)lmp->is);
#line 3896
      __s2_len = __builtin_strlen((char const   *)rmp->is);
#line 3896
      if (! ((unsigned long )((void const   *)(lmp->is + 1)) - (unsigned long )((void const   *)lmp->is) == 1UL)) {
        goto _L___0;
      } else {
#line 3896
        if (__s1_len >= 4UL) {
          _L___0: 
#line 3896
          if (! ((unsigned long )((void const   *)(rmp->is + 1)) - (unsigned long )((void const   *)rmp->is) == 1UL)) {
#line 3896
            tmp___12 = 1;
          } else {
#line 3896
            if (__s2_len >= 4UL) {
#line 3896
              tmp___12 = 1;
            } else {
#line 3896
              tmp___12 = 0;
            }
          }
        } else {
#line 3896
          tmp___12 = 0;
        }
      }
#line 3896
      if (tmp___12) {
#line 3896
        tmp___7 = __builtin_strcmp((char const   *)lmp->is,
                                   (char const   *)rmp->is);
#line 3896
        tmp___11 = tmp___7;
      } else {
#line 3896
        tmp___10 = __builtin_strcmp((char const   *)lmp->is,
                                    (char const   *)rmp->is);
#line 3896
        tmp___11 = tmp___10;
      }
    } else {
#line 3896
      tmp___10 = __builtin_strcmp((char const   *)lmp->is,
                                  (char const   *)rmp->is);
#line 3896
      tmp___11 = tmp___10;
    }
#line 3896
    if (! (tmp___11 == 0)) {
#line 3897
      *(lmp->is + 0) = (char )'\000';
    } else {

    }
#line 3899
    i = 0;
#line 3900
    while (1) {
#line 3900
      if ((int )*(lmp->left + i) != 0) {
#line 3900
        if (! ((int )*(lmp->left + i) == (int )*(rmp->left + i))) {
#line 3900
          break;
        } else {

        }
      } else {
#line 3900
        break;
      }
#line 3901
      i ++;
    }
#line 3902
    *(lmp->left + i) = (char )'\000';
#line 3904
    tmp___13 = strlen((char const   *)lmp->right);
#line 3904
    ln = (int )tmp___13;
#line 3905
    tmp___14 = strlen((char const   *)rmp->right);
#line 3905
    rn = (int )tmp___14;
#line 3906
    n = ln;
#line 3907
    if (n > rn) {
#line 3908
      n = rn;
    } else {

    }
#line 3909
    i = 0;
#line 3909
    while (i < n) {
#line 3910
      if ((int )*(lmp->right + ((ln - i) - 1)) != (int )*(rmp->right + ((rn - i) - 1))) {
#line 3911
        break;
      } else {

      }
#line 3909
      i ++;
    }
#line 3912
    j = 0;
#line 3912
    while (j < i) {
#line 3913
      *(lmp->right + j) = *(lmp->right + ((ln - i) + j));
#line 3912
      j ++;
    }
#line 3914
    *(lmp->right + j) = (char )'\000';
#line 3915
    new = inboth(lmp->in, rmp->in);
#line 3916
    if ((unsigned long )new == (unsigned long )((void *)0)) {
      goto done;
    } else {

    }
#line 3918
    freelist(lmp->in);
#line 3919
    free((void *)lmp->in);
#line 3920
    lmp->in = new;
#line 3922
    break;
    case 266: 
#line 3924
    if (! ((unsigned long )musts < (unsigned long )mp)) {
#line 3924
      __assert_fail("musts < mp", "dfa.c", 3924U, "dfamust");
    } else {

    }
#line 3925
    mp --;
#line 3926
    *(mp->is + 0) = (char )'\000';
#line 3927
    break;
    case -1: 
#line 3929
    if (! ((unsigned long )mp == (unsigned long )(musts + 1))) {
#line 3929
      __assert_fail("mp == &musts[1]", "dfa.c", 3929U, "dfamust");
    } else {

    }
#line 3930
    i = 0;
#line 3930
    while ((unsigned long )*((musts + 0)->in + i) != (unsigned long )((void *)0)) {
#line 3931
      tmp___15 = strlen((char const   *)*((musts + 0)->in + i));
#line 3931
      tmp___16 = strlen((char const   *)result);
#line 3931
      if (tmp___15 > tmp___16) {
#line 3932
        result = *((musts + 0)->in + i);
      } else {

      }
#line 3930
      i ++;
    }
#line 3933
    if (0) {
#line 3933
      __s1_len___0 = __builtin_strlen((char const   *)result);
#line 3933
      __s2_len___0 = __builtin_strlen((char const   *)(musts + 0)->is);
#line 3933
      if (! ((unsigned long )((void const   *)(result + 1)) - (unsigned long )((void const   *)result) == 1UL)) {
        goto _L___2;
      } else {
#line 3933
        if (__s1_len___0 >= 4UL) {
          _L___2: 
#line 3933
          if (! ((unsigned long )((void const   *)((musts + 0)->is + 1)) - (unsigned long )((void const   *)(musts + 0)->is) == 1UL)) {
#line 3933
            tmp___23 = 1;
          } else {
#line 3933
            if (__s2_len___0 >= 4UL) {
#line 3933
              tmp___23 = 1;
            } else {
#line 3933
              tmp___23 = 0;
            }
          }
        } else {
#line 3933
          tmp___23 = 0;
        }
      }
#line 3933
      if (tmp___23) {
#line 3933
        tmp___18 = __builtin_strcmp((char const   *)result,
                                    (char const   *)(musts + 0)->is);
#line 3933
        tmp___22 = tmp___18;
      } else {
#line 3933
        tmp___21 = __builtin_strcmp((char const   *)result,
                                    (char const   *)(musts + 0)->is);
#line 3933
        tmp___22 = tmp___21;
      }
    } else {
#line 3933
      tmp___21 = __builtin_strcmp((char const   *)result,
                                  (char const   *)(musts + 0)->is);
#line 3933
      tmp___22 = tmp___21;
    }
#line 3933
    if (tmp___22 == 0) {
#line 3934
      exact = 1;
    } else {

    }
    goto done;
    case 268: 
#line 3937
    if (! ((unsigned long )(musts + 2) <= (unsigned long )mp)) {
#line 3937
      __assert_fail("&musts[2] <= mp", "dfa.c", 3937U, "dfamust");
    } else {

    }
#line 3942
    mp --;
#line 3942
    rmp___0 = mp;
#line 3943
    mp --;
#line 3943
    lmp___0 = mp;
#line 3947
    lmp___0->in = addlists(lmp___0->in, rmp___0->in);
#line 3948
    if ((unsigned long )lmp___0->in == (unsigned long )((void *)0)) {
      goto done;
    } else {

    }
#line 3950
    if ((int )*(lmp___0->right + 0) != 0) {
#line 3950
      if ((int )*(rmp___0->left + 0) != 0) {
#line 3955
        tp = icpyalloc((char const   *)lmp___0->right);
#line 3956
        if ((unsigned long )tp == (unsigned long )((void *)0)) {
          goto done;
        } else {

        }
#line 3958
        tp = icatalloc(tp, (char const   *)rmp___0->left);
#line 3959
        if ((unsigned long )tp == (unsigned long )((void *)0)) {
          goto done;
        } else {

        }
#line 3961
        tmp___24 = strlen((char const   *)tp);
#line 3961
        lmp___0->in = enlist(lmp___0->in, tp, tmp___24);
#line 3963
        free((void *)tp);
#line 3964
        if ((unsigned long )lmp___0->in == (unsigned long )((void *)0)) {
          goto done;
        } else {

        }
      } else {

      }
    } else {

    }
#line 3968
    if ((int )*(lmp___0->is + 0) != 0) {
#line 3970
      lmp___0->left = icatalloc(lmp___0->left, (char const   *)rmp___0->left);
#line 3972
      if ((unsigned long )lmp___0->left == (unsigned long )((void *)0)) {
        goto done;
      } else {

      }
    } else {

    }
#line 3976
    if ((int )*(rmp___0->is + 0) == 0) {
#line 3977
      *(lmp___0->right + 0) = (char )'\000';
    } else {

    }
#line 3978
    lmp___0->right = icatalloc(lmp___0->right, (char const   *)rmp___0->right);
#line 3979
    if ((unsigned long )lmp___0->right == (unsigned long )((void *)0)) {
      goto done;
    } else {

    }
#line 3982
    if ((int )*(lmp___0->is + 0) != 0) {
#line 3982
      if ((int )*(rmp___0->is + 0) != 0) {
#line 3984
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
#line 3985
        if ((unsigned long )lmp___0->is == (unsigned long )((void *)0)) {
          goto done;
        } else {

        }
      } else {
#line 3989
        *(lmp___0->is + 0) = (char )'\000';
      }
    } else {
#line 3989
      *(lmp___0->is + 0) = (char )'\000';
    }
#line 3991
    break;
    default: ;
#line 3993
    if ((int )t < -1) {
#line 3995
      __assert_fail("!\"oops! t >= END\"", "dfa.c", 3995U, "dfamust");
    } else {
#line 3997
      if ((int )t == 0) {
        goto done;
      } else {
#line 4002
        if ((int )t >= 275) {
#line 4010
          resetmust(mp);
        } else {
#line 4002
          if ((int )t == 272) {
#line 4010
            resetmust(mp);
          } else {
#line 4002
            if ((int )t == 273) {
#line 4010
              resetmust(mp);
            } else {
#line 4015
              resetmust(mp);
#line 4016
              tmp___26 = (char )t;
#line 4016
              *(mp->right + 0) = tmp___26;
#line 4016
              tmp___25 = tmp___26;
#line 4016
              *(mp->left + 0) = tmp___25;
#line 4016
              *(mp->is + 0) = tmp___25;
#line 4017
              tmp___28 = (char )'\000';
#line 4017
              *(mp->right + 1) = tmp___28;
#line 4017
              tmp___27 = tmp___28;
#line 4017
              *(mp->left + 1) = tmp___27;
#line 4017
              *(mp->is + 1) = tmp___27;
#line 4018
              mp->in = enlist(mp->in, mp->is, 1UL);
#line 4019
              if ((unsigned long )mp->in == (unsigned long )((void *)0)) {
                goto done;
              } else {

              }
            }
          }
        }
      }
    }
#line 4022
    break;
    }
#line 4034
    mp ++;
#line 3862
    ri ++;
  }
   4383: /* CIL Label */ 
  done: 
#line 4037
  tmp___37 = strlen((char const   *)result);
   4384: /* CIL Label */ 
#line 4037
  if (tmp___37) {
#line 4039
    if (sizeof(struct dfamust ) == 1UL) {
#line 4039
      tmp___29 = xmalloc(1UL);
#line 4039
      tmp___31 = tmp___29;
    } else {
#line 4039
      tmp___30 = xnmalloc(1UL, sizeof(struct dfamust ));
#line 4039
      tmp___31 = tmp___30;
    }
#line 4039
    dm = (struct dfamust *)tmp___31;
#line 4040
    dm->exact = exact;
#line 4041
    if (sizeof(char ) == 1UL) {
#line 4041
      tmp___32 = strlen((char const   *)result);
#line 4041
      tmp___33 = xmalloc(tmp___32 + 1UL);
#line 4041
      tmp___36 = tmp___33;
    } else {
#line 4041
      tmp___34 = strlen((char const   *)result);
#line 4041
      tmp___35 = xnmalloc(tmp___34 + 1UL, sizeof(char ));
#line 4041
      tmp___36 = tmp___35;
    }
#line 4041
    dm->must = (char *)tmp___36;
#line 4042
    strcpy((char */* __restrict  */)dm->must,
           (char const   */* __restrict  */)result);
#line 4043
    dm->next = d->musts;
#line 4044
    d->musts = dm;
  } else {

  }
   4385: /* CIL Label */ 
#line 4046
  mp = musts;
   4386: /* CIL Label */ 
#line 4047
  i = 0;
   4387: /* CIL Label */ 
#line 4047
  while (i <= d->tindex) {
#line 4049
    freelist((mp + i)->in);
#line 4050
    free((void *)(mp + i)->in);
#line 4051
    free((void *)(mp + i)->left);
#line 4052
    free((void *)(mp + i)->right);
#line 4053
    free((void *)(mp + i)->is);
#line 4047
    i ++;
  }
   4388: /* CIL Label */ 
#line 4055
  free((void *)mp);
   4389: /* CIL Label */ 
#line 4056
  return;
}
}

cilRep: liveness failure for dfamust: Errormsg.Error
cilRep: computed liveness
cilrep: from_source: post: stmt_count: 4392
faultLocRep: compute_localization: fault_scheme: path, fix_scheme: default
Rep: coverage_sourcename: /home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/coverage/coverage.c
cilRep: instrumenting for fault localization
cilRep: WARNING: definition of fprintf found at /usr/include/x86_64-linux-gnu/bits/stdio2.h:94
	cannot instrument for coverage (would be recursive)
cilRep: WARNING: definition of fprintf found at /usr/include/x86_64-linux-gnu/bits/string3.h:75
	cannot instrument for coverage (would be recursive)
cilRep: done instrumenting for fault localization
coverage negative:
	test: 1
/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
coverage positive:
	test: 1
id:32
in directory:/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/tests
calling:make check-TESTS TESTS=reversed-range-endpoints
PASS:32
	test: 2
id:33
in directory:/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/tests
calling:make check-TESTS TESTS=yesno
PASS:33
cilRep: default.cache: saved
cachingRep: default.cache: saved
faultlocRep: default.cache: saved
cilrep done serialize
cilRep: stmt_count = 4392
cilRep: stmts in weighted_path = 182
cilRep: total weight = 98.3
cilRep: stmts in weighted_path with weight >= 1.0 = 89
cilRep: src/dfa.c (code bank/base file; atoms [1,4392])
cilRep: 1 file(s) total in representation
search: ww_adaptive_1 begins (time = 1454306304.270353)
cilRep: coverage ignores: /usr/lib/gcc/x86_64-linux-gnu/4.8/include
cilRep: coverage ignores: /usr/local/include
cilRep: coverage ignores: /usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed
cilRep: coverage ignores: /usr/include
cilRep: atoms in standard headers: 690
cilRep: fix-space quotient by string: 200 -> 157
progeq: WARNING: cannot resolve call: xmalloc
progeq: WARNING: cannot resolve call: xalloc_die
progeq: computing alias analysis information
progeq: WARNING: cannot resolve call: __ctype_tolower_loc
progeq: WARNING: cannot resolve call: __ctype_toupper_loc
progeq: WARNING: cannot resolve call: __builtin_expect
progeq: WARNING: cannot resolve call: __uflow
progeq: WARNING: cannot resolve call: __overflow
progeq: WARNING: cannot resolve call: __getdelim
progeq: WARNING: cannot resolve call: __builtin_object_size
progeq: WARNING: cannot resolve call: __builtin___sprintf_chk
progeq: WARNING: cannot resolve call: __builtin___vsprintf_chk
progeq: WARNING: cannot resolve call: __builtin___snprintf_chk
progeq: WARNING: cannot resolve call: __builtin___vsnprintf_chk
progeq: WARNING: cannot resolve call: __fprintf_chk
progeq: WARNING: cannot resolve call: __printf_chk
progeq: WARNING: cannot resolve call: __vfprintf_chk
progeq: WARNING: cannot resolve call: __dprintf_chk
progeq: WARNING: cannot resolve call: __vdprintf_chk
progeq: WARNING: cannot resolve call: __asprintf_chk
progeq: WARNING: cannot resolve call: __obstack_printf_chk
progeq: WARNING: cannot resolve call: __vasprintf_chk
progeq: WARNING: cannot resolve call: __obstack_vprintf_chk
progeq: WARNING: cannot resolve call: __fgets_chk
progeq: WARNING: cannot resolve call: __fgets_chk_warn
progeq: WARNING: cannot resolve call: __fgets_alias
progeq: WARNING: cannot resolve call: __fread_chk
progeq: WARNING: cannot resolve call: __fread_chk_warn
progeq: WARNING: cannot resolve call: __fread_alias
progeq: WARNING: cannot resolve call: __fgets_unlocked_chk
progeq: WARNING: cannot resolve call: __fgets_unlocked_chk_warn
progeq: WARNING: cannot resolve call: __fgets_unlocked_alias
progeq: WARNING: cannot resolve call: __fread_unlocked_chk
progeq: WARNING: cannot resolve call: __fread_unlocked_chk_warn
progeq: WARNING: cannot resolve call: __fread_unlocked_alias
progeq: WARNING: cannot resolve call: *__compar
progeq: WARNING: cannot resolve call: __realpath_chk
progeq: WARNING: cannot resolve call: __realpath_alias
progeq: WARNING: cannot resolve call: __ptsname_r_chk
progeq: WARNING: cannot resolve call: __ptsname_r_chk_warn
progeq: WARNING: cannot resolve call: __ptsname_r_alias
progeq: WARNING: cannot resolve call: __wctomb_chk
progeq: WARNING: cannot resolve call: __wctomb_alias
progeq: WARNING: cannot resolve call: __mbstowcs_chk
progeq: WARNING: cannot resolve call: __mbstowcs_chk_warn
progeq: WARNING: cannot resolve call: __mbstowcs_alias
progeq: WARNING: cannot resolve call: __wcstombs_chk
progeq: WARNING: cannot resolve call: __wcstombs_chk_warn
progeq: WARNING: cannot resolve call: __wcstombs_alias
progeq: WARNING: cannot resolve call: __builtin_strchr
progeq: WARNING: cannot resolve call: __builtin___memcpy_chk
progeq: WARNING: cannot resolve call: __builtin___memmove_chk
progeq: WARNING: cannot resolve call: __builtin___mempcpy_chk
progeq: WARNING: cannot resolve call: __builtin___memset_chk
progeq: WARNING: cannot resolve call: __builtin___strcpy_chk
progeq: WARNING: cannot resolve call: __builtin___stpcpy_chk
progeq: WARNING: cannot resolve call: __builtin___strncpy_chk
progeq: WARNING: cannot resolve call: __stpncpy_chk
progeq: WARNING: cannot resolve call: __stpncpy_alias
progeq: WARNING: cannot resolve call: __builtin___strcat_chk
progeq: WARNING: cannot resolve call: __builtin___strncat_chk
progeq: WARNING: cannot resolve call: __btowc_alias
progeq: WARNING: cannot resolve call: __wctob_alias
progeq: WARNING: cannot resolve call: mbrtowc
progeq: WARNING: cannot resolve call: __mbrlen
progeq: WARNING: cannot resolve call: __wmemcpy_chk
progeq: WARNING: cannot resolve call: __wmemcpy_chk_warn
progeq: WARNING: cannot resolve call: __wmemcpy_alias
progeq: WARNING: cannot resolve call: __wmemmove_chk
progeq: WARNING: cannot resolve call: __wmemmove_chk_warn
progeq: WARNING: cannot resolve call: __wmemmove_alias
progeq: WARNING: cannot resolve call: __wmempcpy_chk
progeq: WARNING: cannot resolve call: __wmempcpy_chk_warn
progeq: WARNING: cannot resolve call: __wmempcpy_alias
progeq: WARNING: cannot resolve call: __wmemset_chk
progeq: WARNING: cannot resolve call: __wmemset_chk_warn
progeq: WARNING: cannot resolve call: __wmemset_alias
progeq: WARNING: cannot resolve call: __wcscpy_chk
progeq: WARNING: cannot resolve call: __wcscpy_alias
progeq: WARNING: cannot resolve call: __wcpcpy_chk
progeq: WARNING: cannot resolve call: __wcpcpy_alias
progeq: WARNING: cannot resolve call: __wcsncpy_chk
progeq: WARNING: cannot resolve call: __wcsncpy_chk_warn
progeq: WARNING: cannot resolve call: __wcsncpy_alias
progeq: WARNING: cannot resolve call: __wcpncpy_chk
progeq: WARNING: cannot resolve call: __wcpncpy_chk_warn
progeq: WARNING: cannot resolve call: __wcpncpy_alias
progeq: WARNING: cannot resolve call: __wcscat_chk
progeq: WARNING: cannot resolve call: __wcscat_alias
progeq: WARNING: cannot resolve call: __wcsncat_chk
progeq: WARNING: cannot resolve call: __wcsncat_alias
progeq: WARNING: cannot resolve call: __swprintf_chk
progeq: WARNING: cannot resolve call: __swprintf_alias
progeq: WARNING: cannot resolve call: __vswprintf_chk
progeq: WARNING: cannot resolve call: __vswprintf_alias
progeq: WARNING: cannot resolve call: __wprintf_chk
progeq: WARNING: cannot resolve call: __fwprintf_chk
progeq: WARNING: cannot resolve call: __vwprintf_chk
progeq: WARNING: cannot resolve call: __vfwprintf_chk
progeq: WARNING: cannot resolve call: __fgetws_chk
progeq: WARNING: cannot resolve call: __fgetws_chk_warn
progeq: WARNING: cannot resolve call: __fgetws_alias
progeq: WARNING: cannot resolve call: __fgetws_unlocked_chk
progeq: WARNING: cannot resolve call: __fgetws_unlocked_chk_warn
progeq: WARNING: cannot resolve call: __fgetws_unlocked_alias
progeq: WARNING: cannot resolve call: __wcrtomb_chk
progeq: WARNING: cannot resolve call: __wcrtomb_alias
progeq: WARNING: cannot resolve call: __mbsrtowcs_chk
progeq: WARNING: cannot resolve call: __mbsrtowcs_chk_warn
progeq: WARNING: cannot resolve call: __mbsrtowcs_alias
progeq: WARNING: cannot resolve call: __wcsrtombs_chk
progeq: WARNING: cannot resolve call: __wcsrtombs_chk_warn
progeq: WARNING: cannot resolve call: __wcsrtombs_alias
progeq: WARNING: cannot resolve call: __mbsnrtowcs_chk
progeq: WARNING: cannot resolve call: __mbsnrtowcs_chk_warn
progeq: WARNING: cannot resolve call: __mbsnrtowcs_alias
progeq: WARNING: cannot resolve call: __wcsnrtombs_chk
progeq: WARNING: cannot resolve call: __wcsnrtombs_chk_warn
progeq: WARNING: cannot resolve call: __wcsnrtombs_alias
progeq: WARNING: cannot resolve call: xrealloc
progeq: WARNING: cannot resolve call: __ctype_get_mb_cur_max
progeq: WARNING: cannot resolve call: nl_langinfo
progeq: WARNING: cannot resolve call: __builtin_strlen
progeq: WARNING: cannot resolve call: __builtin_strcmp
progeq: WARNING: cannot resolve call: dcgettext
progeq: WARNING: cannot resolve call: dfaerror
progeq: WARNING: cannot resolve call: *(pred->func)
progeq: WARNING: cannot resolve call: regcomp
progeq: WARNING: cannot resolve call: regexec
progeq: WARNING: cannot resolve call: regfree
progeq: WARNING: cannot resolve call: dfawarn
progeq: WARNING: cannot resolve call: __assert_fail
progeq: WARNING: cannot resolve call: hard_locale
progeq: WARNING: cannot resolve call: xzalloc
progeq: WARNING: cannot resolve call: xcalloc
progeq: WARNING: cannot resolve call: free
progeq: WARNING: cannot resolve call: realloc
search: fix space reduced (time_taken = 70.1605)
excluded 0 deletes (from list of 0 total edits)
search: ww_adaptive: 173 deletes
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:17:after17
REMOVED?true
CARDINAL?before:17:after17
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:17:after17
REMOVED?true
CARDINAL?before:17:after17
REMOVED?true
CARDINAL?before:17:after17
REMOVED?true
CARDINAL?before:4:after4
REMOVED?true
CARDINAL?before:4:after4
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:7:after7
REMOVED?true
CARDINAL?before:7:after7
REMOVED?true
CARDINAL?before:7:after7
REMOVED?true
CARDINAL?before:7:after7
REMOVED?true
CARDINAL?before:7:after7
REMOVED?true
CARDINAL?before:7:after7
REMOVED?true
CARDINAL?before:7:after7
REMOVED?true
CARDINAL?before:7:after7
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:89:after89
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:148:after148
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:52:after52
REMOVED?true
CARDINAL?before:52:after52
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:5:after5
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:5:after5
REMOVED?true
CARDINAL?before:5:after5
REMOVED?true
CARDINAL?before:5:after5
REMOVED?true
CARDINAL?before:5:after5
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:4:after4
REMOVED?true
CARDINAL?before:4:after4
REMOVED?true
CARDINAL?before:4:after4
REMOVED?true
CARDINAL?before:148:after148
REMOVED?true
CARDINAL?before:4:after4
REMOVED?true
CARDINAL?before:4:after4
REMOVED?true
CARDINAL?before:4:after4
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:38:after38
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:17:after17
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:17:after17
REMOVED?true
CARDINAL?before:17:after17
REMOVED?true
CARDINAL?before:17:after17
REMOVED?true
CARDINAL?before:17:after17
REMOVED?true
CARDINAL?before:148:after148
REMOVED?true
CARDINAL?before:17:after17
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:4:after4
REMOVED?true
CARDINAL?before:4:after4
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:89:after89
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:20:after20
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:78:after78
REMOVED?true
CARDINAL?before:6:after6
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:58:after58
REMOVED?true
CARDINAL?before:58:after58
REMOVED?true
CARDINAL?before:52:after52
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:16:after16
REMOVED?true
CARDINAL?before:16:after16
REMOVED?true
CARDINAL?before:16:after16
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:144:after144
REMOVED?true
CARDINAL?before:16:after16
REMOVED?true
CARDINAL?before:16:after16
REMOVED?true
CARDINAL?before:16:after16
REMOVED?true
CARDINAL?before:16:after16
REMOVED?true
CARDINAL?before:16:after16
REMOVED?true
CARDINAL?before:106:after106
REMOVED?true
CARDINAL?before:16:after16
REMOVED?true
CARDINAL?before:148:after148
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:24:after24
REMOVED?true
CARDINAL?before:157:after157
REMOVED?true
CARDINAL?before:2:after2
REMOVED?true
CARDINAL?before:2:after2
REMOVED?true
CARDINAL?before:2:after2
REMOVED?true
CARDINAL?before:2:after2
REMOVED?true
excluded 0 deletes (from list of 0 total edits)
search: ww_adaptive: 10827 appends
excluded 0 appends (from list of 0 total edits)
search: ww_adaptive: 4716 appends
search: ww_adaptive: 15543 possible edits
search: ready to start (time_taken = 92.2913)
search: ww_adaptive: finding best
rep: WARNING: test_visiting_atoms: no data available
	try using --coverage-per-test and/or --regen-paths
	defaulting to 'all tests'
search: ww_adaptive: found best (time_taken = 0.0861609)
	variant     1/15543 = d(3859)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 3.37121)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.138787)
	variant     2/15543 = d(3858)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 6.05353)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.107585)
	variant     3/15543 = d(3857)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 5.08756)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.059602)
	variant     4/15543 = d(3856)         (3 tests, cond 0)
		n1Segmentation fault
id:0
FAILED:0
 false (test_time = 2.77173)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.0994461)
	variant     5/15543 = d(3855)         (3 tests, cond 0)
		n1Segmentation fault
id:0
FAILED:0
 false (test_time = 2.95661)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.112349)
	variant     6/15543 = d(3854)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 7.48541)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.084446)
	variant     7/15543 = d(3853)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 2.86149)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.147393)
	variant     8/15543 = d(3852)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 6.2626)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.122331)
	variant     9/15543 = d(3851)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 3.24223)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.138344)
	variant    10/15543 = d(3850)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 3.35276)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.113278)
	variant    11/15543 = d(3848)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 2.96326)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.0898361)
	variant    12/15543 = d(3847)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 3.08339)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.0711329)
	variant    13/15543 = d(3846)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 3.82107)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.0667491)
	variant    14/15543 = d(3845)         (3 tests, cond 0)
		n1Segmentation fault
id:0
FAILED:0
 false (test_time = 2.72418)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.111672)
	variant    15/15543 = d(3844)         (3 tests, cond 0)
		n1Segmentation fault
id:0
FAILED:0
 false (test_time = 2.74444)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.074945)
	variant    16/15543 = d(3843)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 4.18789)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.110552)
	variant    17/15543 = d(3842)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 4.30054)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.140129)
	variant    18/15543 = d(3841)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 3.04369)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.0844741)
	variant    19/15543 = d(3838)         (3 tests, cond 0)
		n1Segmentation fault
id:0
FAILED:0
 false (test_time = 3.77459)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.109208)
	variant    20/15543 = d(3837)         (3 tests, cond 0)
		n1Segmentation fault
id:0
FAILED:0
 false (test_time = 3.26825)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.102563)
	variant    21/15543 = d(3834)         (3 tests, cond 0)
		n1Segmentation fault
id:0
FAILED:0
 false (test_time = 4.13658)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.127282)
	variant    22/15543 = d(3833)         (3 tests, cond 0)
		n1Segmentation fault
id:0
FAILED:0
 false (test_time = 3.03602)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.125149)
	variant    23/15543 = d(3830)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 4.49198)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.120182)
	variant    24/15543 = d(3829)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 3.21992)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.126675)
	variant    25/15543 = d(4391)         (3 tests, cond 0)
		n1/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/src/grep: memory exhausted
id:0
FAILED:0
 false (test_time = 4.21534)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.128134)
	variant    26/15543 = d(4390)         (3 tests, cond 0)
		n1Segmentation fault
id:0
FAILED:0
 false (test_time = 2.55954)
search: ww_adaptive: finding best
search: ww_adaptive: found best (time_taken = 0.0980759)
	variant    27/15543 = d(3877)         (3 tests, cond 0)
		n1id:0
PASS:0
 true (test_time = 2.50996)
		p1id:32
in directory:/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/tests
calling:make check-TESTS TESTS=reversed-range-endpoints
PASS:32
 true (test_time = 0.704929)
		p2id:33
in directory:/home/ubuntu/corebench/grep/grep-case-62458291-3c3bdace/tests
calling:make check-TESTS TESTS=yesno
PASS:33
 true (test_time = 1.26309)
search: ww_adaptive: ends (yes repair)

Repair Found: d(3877)
Repair Name: d(3877) 
Test Condition: 0
Test Cases Skipped: ""
Current Time: 1454306574.242808

Variant Test Case Queries: 29
"Test Suite Evaluations": 9.66667

Compile Failures: 0
Wall-Clock Seconds Elapsed: 280.491
  Activity Name                     Count Seconds = Percent of Total Time
  find_best_edit                       27   2.896 = 1.07413%
  test                                 32   6.659 = 2.46983%
  delete_sources                      173  32.718 = 12.135%
  append_sources                      173  59.546 = 22.0854%
  progeq partition                    157  67.406 = 25.0008%
  compile                              28 100.392 = 37.2349%
  TOTAL                                   269.618 = 96.1212% (avg CPU usage)
